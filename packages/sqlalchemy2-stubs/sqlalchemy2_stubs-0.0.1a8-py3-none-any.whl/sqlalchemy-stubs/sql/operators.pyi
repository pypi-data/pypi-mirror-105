from operator import add as add
from operator import and_ as and_
from operator import contains as contains
from operator import eq as eq
from operator import ge as ge
from operator import getitem as getitem
from operator import gt as gt
from operator import inv as inv
from operator import le as le
from operator import lshift as lshift
from operator import lt as lt
from operator import mod as mod
from operator import mul as mul
from operator import ne as ne
from operator import neg as neg
from operator import or_ as or_
from operator import rshift as rshift
from operator import sub as sub
from operator import truediv as truediv
from typing import Any
from typing import Callable
from typing import Optional
from typing import Type
from typing import TypeVar
from typing import Union

from .elements import ClauseElement
from .type_api import TypeEngine

_F = TypeVar("_F", bound=Callable[..., Any])

div = truediv

class Operators:
    def __and__(self, other: Any) -> ClauseElement: ...
    def __or__(self, other: Any) -> ClauseElement: ...
    def __invert__(self) -> ClauseElement: ...
    def op(
        self,
        opstring: Any,
        precedence: int = ...,
        is_comparison: bool = ...,
        return_type: Optional[
            Union[Type[TypeEngine[Any]], TypeEngine[Any]]
        ] = ...,
    ) -> Callable[[Any], ClauseElement]: ...
    def bool_op(
        self, opstring: Any, precedence: int = ...
    ) -> Callable[[Any], ClauseElement]: ...
    def operate(
        self, op: Any, *other: Any, **kwargs: Any
    ) -> ClauseElement: ...
    def reverse_operate(
        self, op: Any, other: Any, **kwargs: Any
    ) -> ClauseElement: ...

class custom_op:
    __name__: str = ...
    opstring: Any = ...
    precedence: int = ...
    is_comparison: bool = ...
    natural_self_precedent: bool = ...
    eager_grouping: bool = ...
    return_type: Optional[Union[Type[TypeEngine[Any]], TypeEngine[Any]]] = ...
    def __init__(
        self,
        opstring: Any,
        precedence: int = ...,
        is_comparison: bool = ...,
        return_type: Optional[
            Union[Type[TypeEngine[Any]], TypeEngine[Any]]
        ] = ...,
        natural_self_precedent: bool = ...,
        eager_grouping: bool = ...,
    ) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __call__(self, left: Any, right: Any, **kw: Any) -> ClauseElement: ...

class ColumnOperators(Operators):
    timetuple: Any = ...
    def __lt__(self, other: Any) -> ClauseElement: ...
    def __le__(self, other: Any) -> ClauseElement: ...
    def __eq__(self, other: Any) -> ClauseElement: ...  # type: ignore[override]
    def __ne__(self, other: Any) -> ClauseElement: ...  # type: ignore[override]
    def is_distinct_from(self, other: Any) -> ClauseElement: ...
    def is_not_distinct_from(self, other: Any) -> ClauseElement: ...
    def isnot_distinct_from(self, other: Any) -> ClauseElement: ...
    def __gt__(self, other: Any) -> ClauseElement: ...
    def __ge__(self, other: Any) -> ClauseElement: ...
    def __neg__(self) -> ClauseElement: ...
    def __contains__(self, other: Any) -> ClauseElement: ...
    def __getitem__(self, index: Any) -> ClauseElement: ...
    def __lshift__(self, other: Any) -> ClauseElement: ...
    def __rshift__(self, other: Any) -> ClauseElement: ...
    def concat(self, other: Any) -> ClauseElement: ...
    def like(
        self, other: Any, escape: Optional[Any] = ...
    ) -> ClauseElement: ...
    def ilike(
        self, other: Any, escape: Optional[Any] = ...
    ) -> ClauseElement: ...
    def in_(self, other: Any) -> ClauseElement: ...
    def not_in(self, other: Any) -> ClauseElement: ...
    def notin_(self, other: Any) -> ClauseElement: ...
    def not_like(
        self, other: Any, escape: Optional[Any] = ...
    ) -> ClauseElement: ...
    def notlike(
        self, other: Any, escape: Optional[Any] = ...
    ) -> ClauseElement: ...
    def not_ilike(
        self, other: Any, escape: Optional[Any] = ...
    ) -> ClauseElement: ...
    def notilike(
        self, other: Any, escape: Optional[Any] = ...
    ) -> ClauseElement: ...
    def is_(self, other: Any) -> ClauseElement: ...
    def is_not(self, other: Any) -> ClauseElement: ...
    isnot: Any = ...
    def startswith(self, other: Any, **kwargs: Any) -> ClauseElement: ...
    def endswith(self, other: Any, **kwargs: Any) -> ClauseElement: ...
    def contains(self, other: Any, **kwargs: Any) -> ClauseElement: ...
    def match(self, other: Any, **kwargs: Any) -> ClauseElement: ...
    def regexp_match(
        self, pattern: Any, flags: Optional[Any] = ...
    ) -> ClauseElement: ...
    def regexp_replace(
        self, pattern: Any, replacement: Any, flags: Optional[Any] = ...
    ) -> ClauseElement: ...
    def desc(self) -> ClauseElement: ...
    def asc(self) -> ClauseElement: ...
    def nulls_first(self) -> ClauseElement: ...
    def nullsfirst(self) -> ClauseElement: ...
    def nulls_last(self) -> ClauseElement: ...
    def nullslast(self) -> ClauseElement: ...
    def collate(self, collation: Any) -> ClauseElement: ...
    def __radd__(self, other: Any) -> ClauseElement: ...
    def __rsub__(self, other: Any) -> ClauseElement: ...
    def __rmul__(self, other: Any) -> ClauseElement: ...
    def __rdiv__(self, other: Any) -> ClauseElement: ...
    def __rmod__(self, other: Any) -> ClauseElement: ...
    def between(
        self, cleft: Any, cright: Any, symmetric: bool = ...
    ) -> ClauseElement: ...
    def distinct(self) -> ClauseElement: ...
    def any_(self) -> ClauseElement: ...
    def all_(self) -> ClauseElement: ...
    def __add__(self, other: Any) -> ClauseElement: ...
    def __sub__(self, other: Any) -> ClauseElement: ...
    def __mul__(self, other: Any) -> ClauseElement: ...
    def __div__(self, other: Any) -> ClauseElement: ...
    def __mod__(self, other: Any) -> ClauseElement: ...
    def __truediv__(self, other: Any) -> ClauseElement: ...
    def __rtruediv__(self, other: Any) -> ClauseElement: ...

def commutative_op(fn: _F) -> _F: ...
def comparison_op(fn: _F) -> _F: ...
def from_() -> None: ...
def function_as_comparison_op() -> None: ...
def as_() -> None: ...
def exists() -> None: ...
def is_true(a: Any) -> None: ...

istrue = is_true

def is_false(a: Any) -> None: ...

isfalse = is_false

def is_distinct_from(a: Any, b: Any) -> ClauseElement: ...
def is_not_distinct_from(a: Any, b: Any) -> ClauseElement: ...

isnot_distinct_from = is_not_distinct_from

def is_(a: Any, b: Any) -> ClauseElement: ...
def is_not(a: Any, b: Any) -> ClauseElement: ...

isnot = is_not

def collate(a: Any, b: Any) -> ClauseElement: ...
def op(a: Any, opstring: str, b: Any) -> ClauseElement: ...
def like_op(a: Any, b: Any, escape: Optional[Any] = ...) -> ClauseElement: ...
def not_like_op(
    a: Any, b: Any, escape: Optional[Any] = ...
) -> ClauseElement: ...

notlike_op = not_like_op

def ilike_op(a: Any, b: Any, escape: Optional[Any] = ...) -> ClauseElement: ...
def not_ilike_op(
    a: Any, b: Any, escape: Optional[Any] = ...
) -> ClauseElement: ...

notilike_op = not_ilike_op

def between_op(
    a: Any, b: Any, c: Any, symmetric: bool = ...
) -> ClauseElement: ...
def not_between_op(
    a: Any, b: Any, c: Any, symmetric: bool = ...
) -> ClauseElement: ...

notbetween_op = not_between_op

def in_op(a: Any, b: Any) -> ClauseElement: ...
def not_in_op(a: Any, b: Any) -> ClauseElement: ...

notin_op = not_in_op

def distinct_op(a: Any) -> ClauseElement: ...
def any_op(a: Any) -> ClauseElement: ...
def all_op(a: Any) -> ClauseElement: ...
def startswith_op(
    a: Any, b: Any, escape: Optional[Any] = ..., autoescape: bool = ...
) -> ClauseElement: ...
def not_startswith_op(
    a: Any, b: Any, escape: Optional[Any] = ..., autoescape: bool = ...
) -> ClauseElement: ...

notstartswith_op = not_startswith_op

def endswith_op(
    a: Any, b: Any, escape: Optional[Any] = ..., autoescape: bool = ...
) -> ClauseElement: ...
def not_endswith_op(
    a: Any, b: Any, escape: Optional[Any] = ..., autoescape: bool = ...
) -> ClauseElement: ...

notendswith_op = not_endswith_op

def contains_op(
    a: Any, b: Any, escape: Optional[Any] = ..., autoescape: bool = ...
) -> ClauseElement: ...
def not_contains_op(
    a: Any, b: Any, escape: Optional[Any] = ..., autoescape: bool = ...
) -> ClauseElement: ...

notcontains_op = not_contains_op

def match_op(a: Any, b: Any, **kw: Any) -> ClauseElement: ...
def regexp_match_op(
    a: Any, b: Any, flags: Optional[Any] = ...
) -> ClauseElement: ...
def not_regexp_match_op(
    a: Any, b: Any, flags: Optional[Any] = ...
) -> ClauseElement: ...
def regexp_replace_op(
    a: Any, b: Any, replacement: Any, flags: Optional[Any] = ...
) -> ClauseElement: ...
def not_match_op(a: Any, b: Any, **kw: Any) -> ClauseElement: ...

notmatch_op = not_match_op

def comma_op(a: Any, b: Any) -> None: ...
def filter_op(a: Any, b: Any) -> None: ...
def concat_op(a: Any, b: Any) -> ClauseElement: ...
def desc_op(a: Any) -> ClauseElement: ...
def asc_op(a: Any) -> ClauseElement: ...
def nulls_first_op(a: Any) -> ClauseElement: ...

nullsfirst_op = nulls_first_op

def nulls_last_op(a: Any) -> ClauseElement: ...

nullslast_op = nulls_last_op

def json_getitem_op(a: Any, b: Any) -> None: ...
def json_path_getitem_op(a: Any, b: Any) -> None: ...
def is_comparison(op: Any) -> bool: ...
def is_commutative(op: Any) -> bool: ...
def is_ordering_modifier(op: Any) -> bool: ...
def is_natural_self_precedent(op: Any) -> bool: ...
def is_boolean(op: Any) -> bool: ...
def mirror(op: Any) -> Any: ...
def is_associative(op: Any) -> bool: ...
def is_precedent(operator: Any, against: Any) -> bool: ...
