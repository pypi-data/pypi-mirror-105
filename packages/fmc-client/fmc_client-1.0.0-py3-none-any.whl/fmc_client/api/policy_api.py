# coding: utf-8

"""
    Cisco Firepower Management Center Open API Specification

    **Specifies the REST URLs and methods supported in the Cisco Firepower Management Center API. Refer to the version specific [REST API Quick Start Guide](https://www.cisco.com/c/en/us/support/security/defense-center/products-programming-reference-guides-list.html) for additional information.**  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: tac@cisco.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from fmc_client.api_client import ApiClient


class PolicyApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_access_policy(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_policy(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessPolicy body: Input representation of access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_access_policy_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_access_policy_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_access_policy_with_http_info(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_policy_with_http_info(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessPolicy body: Input representation of access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_access_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_access_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_access_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_access_policy_category(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_policy_category(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessPolicyCategory body: The input category model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies category in given section. Allowed value is 'mandatory' and 'default'.
        :param str above_category: creates category above specified category.
        :param str insert_before: creates category above given rule index.
        :param str insert_after: creates category below given rule index.
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_access_policy_category_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_access_policy_category_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_access_policy_category_with_http_info(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_policy_category_with_http_info(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessPolicyCategory body: The input category model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies category in given section. Allowed value is 'mandatory' and 'default'.
        :param str above_category: creates category above specified category.
        :param str insert_before: creates category above given rule index.
        :param str insert_after: creates category below given rule index.
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'container_uuid', 'domain_uuid', 'section', 'above_category', 'insert_before', 'insert_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_access_policy_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_access_policy_category`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `create_access_policy_category`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_access_policy_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
        if 'above_category' in params:
            query_params.append(('aboveCategory', params['above_category']))  # noqa: E501
        if 'insert_before' in params:
            query_params.append(('insertBefore', params['insert_before']))  # noqa: E501
        if 'insert_after' in params:
            query_params.append(('insertAfter', params['insert_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/categories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ftd_nat_policy(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ftd_nat_policy(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDNatPolicy body: Input representation of NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ftd_nat_policy_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ftd_nat_policy_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_ftd_nat_policy_with_http_info(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ftd_nat_policy_with_http_info(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDNatPolicy body: Input representation of NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ftd_nat_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_ftd_nat_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_ftd_nat_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ftds2_s_vpn_model(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ftds2_s_vpn_model(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDS2SVpnModel body: Input representation of FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ftds2_s_vpn_model_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ftds2_s_vpn_model_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_ftds2_s_vpn_model_with_http_info(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ftds2_s_vpn_model_with_http_info(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDS2SVpnModel body: Input representation of FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ftds2_s_vpn_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_ftds2_s_vpn_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_ftds2_s_vpn_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDS2SVpnModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_multiple_access_rule(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_access_rule(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations.
        :param str insert_after: This parameter specifies that the rules will be inserted after the specified rule index. If no section or category is specified, the rules will be added to the section or category after the insertion point. insertBefore takes precedence over insertAfter - if both are specified, the insertBefore parameter will apply.
        :param str insert_before: This parameter specifies that the rules will be inserted before the specified rule index. If no section or category is specified, the rules will be added to the section or category before the insertion point. insertBefore takes precedence over insertAfter - if both are specified, the insertBefore parameter will apply.
        :param str section: This parameter specifies the section into which the rules will be added. If this parameter is not used the section will be the default section. Only 'mandatory' and 'default' are allowed values. If a section is specified, a category cannot be specified.
        :param str category: This parameter specifies the category into which the rules will be added. If a category is specified it must exist or the request will fail. If a section is specified, a category cannot be specified.
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_multiple_access_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_multiple_access_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_multiple_access_rule_with_http_info(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_access_rule_with_http_info(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations.
        :param str insert_after: This parameter specifies that the rules will be inserted after the specified rule index. If no section or category is specified, the rules will be added to the section or category after the insertion point. insertBefore takes precedence over insertAfter - if both are specified, the insertBefore parameter will apply.
        :param str insert_before: This parameter specifies that the rules will be inserted before the specified rule index. If no section or category is specified, the rules will be added to the section or category before the insertion point. insertBefore takes precedence over insertAfter - if both are specified, the insertBefore parameter will apply.
        :param str section: This parameter specifies the section into which the rules will be added. If this parameter is not used the section will be the default section. Only 'mandatory' and 'default' are allowed values. If a section is specified, a category cannot be specified.
        :param str category: This parameter specifies the category into which the rules will be added. If a category is specified it must exist or the request will fail. If a section is specified, a category cannot be specified.
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'container_uuid', 'domain_uuid', 'bulk', 'insert_after', 'insert_before', 'section', 'category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multiple_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `create_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_multiple_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501
        if 'insert_after' in params:
            query_params.append(('insertAfter', params['insert_after']))  # noqa: E501
        if 'insert_before' in params:
            query_params.append(('insertBefore', params['insert_before']))  # noqa: E501
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_multiple_ftd_auto_nat_rule(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_ftd_auto_nat_rule(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDAutoNatRule body: The input Auto NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: Enables bulk create for auto nat rules.
        :param str section: Retrieves, creates or modifies auto nat rule in given section. Allowed value is 'auto'.
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_multiple_ftd_auto_nat_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_multiple_ftd_auto_nat_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_multiple_ftd_auto_nat_rule_with_http_info(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_ftd_auto_nat_rule_with_http_info(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDAutoNatRule body: The input Auto NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: Enables bulk create for auto nat rules.
        :param str section: Retrieves, creates or modifies auto nat rule in given section. Allowed value is 'auto'.
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'container_uuid', 'domain_uuid', 'bulk', 'section']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multiple_ftd_auto_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_multiple_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `create_multiple_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_multiple_ftd_auto_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/autonatrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDAutoNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_multiple_ftd_manual_nat_rule(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_ftd_manual_nat_rule(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDManualNatRule body: The input Manual NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: Enables bulk create for manual nat rules.
        :param str section: Retrieves, creates or modifies manual nat rule in given section. Allowed value is 'before_auto' and 'after_auto'.
        :param str target_index: Creates or modifies manual nat rule at given targetIndex. It takes an integer value.
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_multiple_ftd_manual_nat_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_multiple_ftd_manual_nat_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_multiple_ftd_manual_nat_rule_with_http_info(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_ftd_manual_nat_rule_with_http_info(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FTDManualNatRule body: The input Manual NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: Enables bulk create for manual nat rules.
        :param str section: Retrieves, creates or modifies manual nat rule in given section. Allowed value is 'before_auto' and 'after_auto'.
        :param str target_index: Creates or modifies manual nat rule at given targetIndex. It takes an integer value.
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'container_uuid', 'domain_uuid', 'bulk', 'section', 'target_index']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multiple_ftd_manual_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_multiple_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `create_multiple_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_multiple_ftd_manual_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
        if 'target_index' in params:
            query_params.append(('targetIndex', params['target_index']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/manualnatrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDManualNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_multiple_prefilter_rule(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_prefilter_rule(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations.
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_multiple_prefilter_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_multiple_prefilter_rule_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_multiple_prefilter_rule_with_http_info(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_multiple_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_multiple_prefilter_rule_with_http_info(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations.
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'container_uuid', 'domain_uuid', 'bulk']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_multiple_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `create_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_multiple_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_prefilter_policy(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prefilter_policy(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PrefilterPolicy body: Input representation of prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_prefilter_policy_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_prefilter_policy_with_http_info(body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_prefilter_policy_with_http_info(self, body, domain_uuid, **kwargs):  # noqa: E501
        """create_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_prefilter_policy_with_http_info(body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PrefilterPolicy body: Input representation of prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_prefilter_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_prefilter_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_prefilter_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_vpn_endpoint(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_vpn_endpoint(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VpnEndpoint body: Input representation of Endpoint. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_vpn_endpoint_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_vpn_endpoint_with_http_info(body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def create_vpn_endpoint_with_http_info(self, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """create_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_vpn_endpoint_with_http_info(body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VpnEndpoint body: Input representation of Endpoint. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_vpn_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `create_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `create_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `create_vpn_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/endpoints', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_access_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str ignore_warning: Shows any warnings when deleting an access policy, if set to false. If not specified, value is set to true and warnings are ignored. Allowed values are 'true' and 'false'.
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_access_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_access_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_access_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str ignore_warning: Shows any warnings when deleting an access policy, if set to false. If not specified, value is set to true and warnings are ignored. Allowed values are 'true' and 'false'.
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid', 'ignore_warning']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_access_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_access_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_access_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'ignore_warning' in params:
            query_params.append(('ignoreWarning', params['ignore_warning']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_access_policy_category(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_policy_category(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a category. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_access_policy_category_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_access_policy_category_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_access_policy_category_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_policy_category_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a category. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_access_policy_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_access_policy_category`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_access_policy_category`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_access_policy_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/categories/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_access_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an access control rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_access_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_access_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_access_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an access control rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_access_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ftd_auto_nat_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftd_auto_nat_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an Auto NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ftd_auto_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ftd_auto_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_ftd_auto_nat_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftd_auto_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an Auto NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ftd_auto_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_ftd_auto_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/autonatrules/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDAutoNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ftd_manual_nat_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftd_manual_nat_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a Manual NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ftd_manual_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ftd_manual_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_ftd_manual_nat_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftd_manual_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a Manual NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ftd_manual_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_ftd_manual_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/manualnatrules/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDManualNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ftd_nat_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftd_nat_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ftd_nat_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ftd_nat_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_ftd_nat_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftd_nat_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ftd_nat_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_ftd_nat_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_ftd_nat_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ftds2_s_vpn_model(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftds2_s_vpn_model(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ftds2_s_vpn_model_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ftds2_s_vpn_model_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_ftds2_s_vpn_model_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ftds2_s_vpn_model_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ftds2_s_vpn_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_ftds2_s_vpn_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_ftds2_s_vpn_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDS2SVpnModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_hit_count(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hit_count(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of access rules if set to list of rule UUIDs. If this key is not used, all access rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: HitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_hit_count_with_http_info(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hit_count_with_http_info(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of access rules if set to list of rule UUIDs. If this key is not used, all access rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: HitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_hit_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `delete_hit_count`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_hit_count`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_hit_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/operational/hitcounts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HitCount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_multiple_access_rule(self, bulk, filter, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_multiple_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_multiple_access_rule(bulk, filter, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param str filter: To be used in conjunction with <code>bulk=true</code> for bulk deletion. Value is of format (including quotes): <code>\"ids:id1,id2,...\"</code>.<br/><code>ids</code> is a comma-separated list of rule IDs to be deleted. (required)
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_multiple_access_rule_with_http_info(bulk, filter, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_multiple_access_rule_with_http_info(bulk, filter, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_multiple_access_rule_with_http_info(self, bulk, filter, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_multiple_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_multiple_access_rule_with_http_info(bulk, filter, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param str filter: To be used in conjunction with <code>bulk=true</code> for bulk deletion. Value is of format (including quotes): <code>\"ids:id1,id2,...\"</code>.<br/><code>ids</code> is a comma-separated list of rule IDs to be deleted. (required)
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bulk', 'filter', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_multiple_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bulk' is set
        if self.api_client.client_side_validation and ('bulk' not in params or
                                                       params['bulk'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `bulk` when calling `delete_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `delete_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `delete_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_multiple_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_multiple_prefilter_rule(self, bulk, filter, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_multiple_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_multiple_prefilter_rule(bulk, filter, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param str filter: To be used in conjunction with <code>bulk=true</code> for bulk deletion. Value is of format (including quotes): <code>\"ids:id1,id2,...\"</code>.<br/><code>ids</code> is a comma-separated list of rule IDs to be deleted. (required)
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_multiple_prefilter_rule_with_http_info(bulk, filter, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_multiple_prefilter_rule_with_http_info(bulk, filter, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_multiple_prefilter_rule_with_http_info(self, bulk, filter, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_multiple_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_multiple_prefilter_rule_with_http_info(bulk, filter, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param str filter: To be used in conjunction with <code>bulk=true</code> for bulk deletion. Value is of format (including quotes): <code>\"ids:id1,id2,...\"</code>.<br/><code>ids</code> is a comma-separated list of rule IDs to be deleted. (required)
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bulk', 'filter', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_multiple_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bulk' is set
        if self.api_client.client_side_validation and ('bulk' not in params or
                                                       params['bulk'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `bulk` when calling `delete_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `delete_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `delete_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_multiple_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_prefilter_hit_count(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_prefilter_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prefilter_hit_count(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of prefilter rules if set to list of rule UUIDs. If this key is not used, all prefilter rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterHitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_prefilter_hit_count_with_http_info(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_prefilter_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of prefilter rules if set to list of rule UUIDs. If this key is not used, all prefilter rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterHitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_prefilter_hit_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `delete_prefilter_hit_count`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_prefilter_hit_count`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_prefilter_hit_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/operational/hitcounts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterHitCount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_prefilter_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prefilter_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_prefilter_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_prefilter_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_prefilter_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """delete_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prefilter_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_prefilter_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_prefilter_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_prefilter_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_prefilter_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prefilter_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a prefilter rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_prefilter_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_prefilter_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_prefilter_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prefilter_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a prefilter rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_vpn_endpoint(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vpn_endpoint(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Endpoint in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_vpn_endpoint_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_vpn_endpoint_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def delete_vpn_endpoint_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """delete_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vpn_endpoint_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Endpoint in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_vpn_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `delete_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `delete_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `delete_vpn_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/endpoints/{objectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_access_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_access_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_access_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_policy_category(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_category(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a category. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_policy_category_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_policy_category_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_access_policy_category_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_category_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a category. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_policy_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_access_policy_category`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_access_policy_category`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_access_policy_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/categories/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_policy_inheritance_setting(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy_inheritance_setting  # noqa: E501

        **Retrieves and modifies the inheritance settings associated with specified Access Policy.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_inheritance_setting(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of the Access Policy Inheritance Setting. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyInheritanceSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_policy_inheritance_setting_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_policy_inheritance_setting_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_access_policy_inheritance_setting_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy_inheritance_setting  # noqa: E501

        **Retrieves and modifies the inheritance settings associated with specified Access Policy.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_inheritance_setting_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of the Access Policy Inheritance Setting. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyInheritanceSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_policy_inheritance_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_access_policy_inheritance_setting`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_access_policy_inheritance_setting`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_access_policy_inheritance_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/inheritancesettings/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyInheritanceSetting',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_policy_logging_setting_model(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy_logging_setting_model  # noqa: E501

        **Retrieves or modifies the logging setting associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_logging_setting_model(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a logging setting. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyLoggingSettingModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_policy_logging_setting_model_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_policy_logging_setting_model_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_access_policy_logging_setting_model_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_policy_logging_setting_model  # noqa: E501

        **Retrieves or modifies the logging setting associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_policy_logging_setting_model_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a logging setting. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyLoggingSettingModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_policy_logging_setting_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_access_policy_logging_setting_model`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_access_policy_logging_setting_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_access_policy_logging_setting_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/loggingsettings/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyLoggingSettingModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an access control rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_access_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an access control rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_access_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_policy(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param str name: If parameter is specified, only the policy matching with the specified name will be displayed. Cannot be used if object ID is specified in path.
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_access_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_access_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_access_policy_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param str name: If parameter is specified, only the policy matching with the specified name will be displayed. Cannot be used if object ID is specified in path.
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'name', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_access_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_policy_category(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_category(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyCategoryListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_access_policy_category_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_access_policy_category_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_access_policy_category_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_category_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyCategoryListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_policy_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_access_policy_category`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_access_policy_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyCategoryListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_policy_inheritance_setting(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy_inheritance_setting  # noqa: E501

        **Retrieves and modifies the inheritance settings associated with specified Access Policy.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_inheritance_setting(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyInheritanceSettingListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_access_policy_inheritance_setting_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_access_policy_inheritance_setting_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_access_policy_inheritance_setting_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy_inheritance_setting  # noqa: E501

        **Retrieves and modifies the inheritance settings associated with specified Access Policy.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_inheritance_setting_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyInheritanceSettingListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_policy_inheritance_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_access_policy_inheritance_setting`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_access_policy_inheritance_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/inheritancesettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyInheritanceSettingListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_policy_logging_setting_model(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy_logging_setting_model  # noqa: E501

        **Retrieves or modifies the logging setting associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_logging_setting_model(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyLoggingSettingModelListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_access_policy_logging_setting_model_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_access_policy_logging_setting_model_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_access_policy_logging_setting_model_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_policy_logging_setting_model  # noqa: E501

        **Retrieves or modifies the logging setting associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_policy_logging_setting_model_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessPolicyLoggingSettingModelListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_policy_logging_setting_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_access_policy_logging_setting_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_access_policy_logging_setting_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/loggingsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyLoggingSettingModelListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_rule(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_rule(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_access_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_access_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_access_rule_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_rule_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: AccessRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRuleListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_default_action(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_default_action(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: DefaultActionListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_default_action_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_default_action_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_default_action_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_default_action_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: DefaultActionListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_default_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_default_action`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_default_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/defaultactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DefaultActionListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_file_policy(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_file_policy  # noqa: E501

        **Retrieves the endpoint device type object associated with the specified ID. If no ID is specified, retrieves list of all endpoint device type objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_file_policy(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FilePolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_file_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_file_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_file_policy_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_file_policy  # noqa: E501

        **Retrieves the endpoint device type object associated with the specified ID. If no ID is specified, retrieves list of all endpoint device type objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_file_policy_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FilePolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_file_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_file_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/filepolicies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilePolicyListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ftd_auto_nat_rule(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_auto_nat_rule(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDAutoNatRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_ftd_auto_nat_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_ftd_auto_nat_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_ftd_auto_nat_rule_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_auto_nat_rule_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDAutoNatRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ftd_auto_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_ftd_auto_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/autonatrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDAutoNatRuleListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ftd_manual_nat_rule(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_manual_nat_rule(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDManualNatRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_ftd_manual_nat_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_ftd_manual_nat_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_ftd_manual_nat_rule_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_manual_nat_rule_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDManualNatRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ftd_manual_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_ftd_manual_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/manualnatrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDManualNatRuleListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ftd_nat_policy(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_nat_policy(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDNatPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_ftd_nat_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_ftd_nat_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_ftd_nat_policy_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_nat_policy_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDNatPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ftd_nat_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_ftd_nat_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatPolicyListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ftd_nat_rule(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_nat_rule  # noqa: E501

        **Retrieves list of all NAT rules (manual and auto) associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_nat_rule(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str filter: Value is of format : <code>\"sourceInterface:name;destinationInterface:name;originalSource:name/value;<br/>originalDestination:name/value;translatedSource:name/value;translatedDestination:name/value;<br/>originalSourcePort:name/value;originalDestinationPort:name/value;translatedSourcePort:name/value;<br/>translatedDestinationPort:name/value\"</code><br/>sourceInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>destinationInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>OriginalSource: Network object configured as Orignal source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalDestination:Network object configured as Destination source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedSource:Network object configured as translated source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedDestination:Network object configured as translated Destination object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalSourcePort:Port object configured as Original Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>originalDestinationPort:Port object configured as Original Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedSourcePort:Port object configured as Translated Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedDestinationPort:Port object configured as Translated Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given\"<br/>
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDNatRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_ftd_nat_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_ftd_nat_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_ftd_nat_rule_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftd_nat_rule  # noqa: E501

        **Retrieves list of all NAT rules (manual and auto) associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftd_nat_rule_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str filter: Value is of format : <code>\"sourceInterface:name;destinationInterface:name;originalSource:name/value;<br/>originalDestination:name/value;translatedSource:name/value;translatedDestination:name/value;<br/>originalSourcePort:name/value;originalDestinationPort:name/value;translatedSourcePort:name/value;<br/>translatedDestinationPort:name/value\"</code><br/>sourceInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>destinationInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>OriginalSource: Network object configured as Orignal source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalDestination:Network object configured as Destination source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedSource:Network object configured as translated source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedDestination:Network object configured as translated Destination object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalSourcePort:Port object configured as Original Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>originalDestinationPort:Port object configured as Original Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedSourcePort:Port object configured as Translated Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedDestinationPort:Port object configured as Translated Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given\"<br/>
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDNatRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'filter', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ftd_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_ftd_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_ftd_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/natrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatRuleListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ftds2_s_vpn_model(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftds2_s_vpn_model(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDS2SVpnModelListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_ftds2_s_vpn_model_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_ftds2_s_vpn_model_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_ftds2_s_vpn_model_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ftds2_s_vpn_model_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: FTDS2SVpnModelListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ftds2_s_vpn_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_ftds2_s_vpn_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDS2SVpnModelListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_intrusion_policy(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_intrusion_policy  # noqa: E501

        **Retrieves the intrusion policy associated with the specified ID. If no ID is specified, retrieves list of all intrusion policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_intrusion_policy(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: IntrusionPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_intrusion_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_intrusion_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_intrusion_policy_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_intrusion_policy  # noqa: E501

        **Retrieves the intrusion policy associated with the specified ID. If no ID is specified, retrieves list of all intrusion policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_intrusion_policy_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: IntrusionPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_intrusion_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_intrusion_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/intrusionpolicies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IntrusionPolicyListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_prefilter_default_action(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_prefilter_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified prefilter control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified prefilter policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_prefilter_default_action(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterDefaultActionListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_prefilter_default_action_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_prefilter_default_action_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_prefilter_default_action_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_prefilter_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified prefilter control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified prefilter policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_prefilter_default_action_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterDefaultActionListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_prefilter_default_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_prefilter_default_action`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_prefilter_default_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/defaultactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterDefaultActionListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_prefilter_policy(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_prefilter_policy(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_prefilter_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_prefilter_policy_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_prefilter_policy_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_prefilter_policy_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterPolicyListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_prefilter_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_prefilter_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterPolicyListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_prefilter_rule(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_prefilter_rule(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str rule_type: If parameter is specified, only the policies with specified <code>ruleType</code> will be shown. Allowed values are 'PREFILTER' and 'TUNNEL'. Cannot be used if object ID is specified in path.
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_prefilter_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_prefilter_rule_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_prefilter_rule_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_prefilter_rule_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str rule_type: If parameter is specified, only the policies with specified <code>ruleType</code> will be shown. Allowed values are 'PREFILTER' and 'TUNNEL'. Cannot be used if object ID is specified in path.
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterRuleListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'rule_type', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'rule_type' in params:
            query_params.append(('ruleType', params['rule_type']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRuleListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_snmp_config(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_snmp_config  # noqa: E501

        **Retrieves the SNMP alert object associated with the specified ID. If no ID is specified, retrieves list of all SNMP alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_snmp_config(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: SNMPConfigListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_snmp_config_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_snmp_config_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_snmp_config_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_snmp_config  # noqa: E501

        **Retrieves the SNMP alert object associated with the specified ID. If no ID is specified, retrieves list of all SNMP alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_snmp_config_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: SNMPConfigListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_snmp_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_snmp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/snmpalerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SNMPConfigListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_syslog_config(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_syslog_config  # noqa: E501

        **Retrieves the syslog alert object associated with the specified ID. If no ID is specified, retrieves list of all syslog alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_syslog_config(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: SyslogConfigListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_syslog_config_with_http_info(domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_syslog_config_with_http_info(domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_syslog_config_with_http_info(self, domain_uuid, **kwargs):  # noqa: E501
        """get_all_syslog_config  # noqa: E501

        **Retrieves the syslog alert object associated with the specified ID. If no ID is specified, retrieves list of all syslog alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_syslog_config_with_http_info(domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: SyslogConfigListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_syslog_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_syslog_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/syslogalerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyslogConfigListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_vpn_advanced_settings(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_advanced_settings  # noqa: E501

        **Retrieves and modifies a Advanced settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single AdvancedSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_advanced_settings(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnAdvancedSettingsListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_vpn_advanced_settings_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_vpn_advanced_settings_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_vpn_advanced_settings_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_advanced_settings  # noqa: E501

        **Retrieves and modifies a Advanced settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single AdvancedSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_advanced_settings_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnAdvancedSettingsListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_vpn_advanced_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_vpn_advanced_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_vpn_advanced_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/advancedsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnAdvancedSettingsListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_vpn_endpoint(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_endpoint(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnEndpointListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_vpn_endpoint_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_vpn_endpoint_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_vpn_endpoint_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_endpoint_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnEndpointListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_vpn_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_vpn_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/endpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnEndpointListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_vpn_ike_settings(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_ike_settings  # noqa: E501

        **Retrieves, deletes, creates, or modifies the IKE Settings associated with the specified ID inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves Ike Settings of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_ike_settings(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnIkeSettingsListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_vpn_ike_settings_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_vpn_ike_settings_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_vpn_ike_settings_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_ike_settings  # noqa: E501

        **Retrieves, deletes, creates, or modifies the IKE Settings associated with the specified ID inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves Ike Settings of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_ike_settings_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnIkeSettingsListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_vpn_ike_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_vpn_ike_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_vpn_ike_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/ikesettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnIkeSettingsListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_vpn_ip_sec_settings(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_ip_sec_settings  # noqa: E501

        **Retrieves and modifies a IPSec Proposal settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single IPSecSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_ip_sec_settings(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnIPSecSettingsListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_vpn_ip_sec_settings_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_vpn_ip_sec_settings_with_http_info(container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_all_vpn_ip_sec_settings_with_http_info(self, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_all_vpn_ip_sec_settings  # noqa: E501

        **Retrieves and modifies a IPSec Proposal settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single IPSecSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_vpn_ip_sec_settings_with_http_info(container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: VpnIPSecSettingsListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_vpn_ip_sec_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_all_vpn_ip_sec_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_all_vpn_ip_sec_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/ipsecsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnIPSecSettingsListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_action(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_action(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: DefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_default_action_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_default_action_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_default_action_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_action_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: DefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_default_action`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_default_action`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_default_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/defaultactions/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DefaultAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_file_policy  # noqa: E501

        **Retrieves the endpoint device type object associated with the specified ID. If no ID is specified, retrieves list of all endpoint device type objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a file policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FilePolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_file_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_file_policy  # noqa: E501

        **Retrieves the endpoint device type object associated with the specified ID. If no ID is specified, retrieves list of all endpoint device type objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a file policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FilePolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_file_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_file_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/filepolicies/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilePolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ftd_auto_nat_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_auto_nat_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an Auto NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies auto nat rule in given section. Allowed value is 'auto'.
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ftd_auto_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ftd_auto_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_ftd_auto_nat_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_auto_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an Auto NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies auto nat rule in given section. Allowed value is 'auto'.
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid', 'section']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ftd_auto_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_ftd_auto_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/autonatrules/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDAutoNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ftd_manual_nat_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_manual_nat_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a Manual NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies manual nat rule in given section. Allowed value is 'before_auto' and 'after_auto'.
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ftd_manual_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ftd_manual_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_ftd_manual_nat_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_manual_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a Manual NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies manual nat rule in given section. Allowed value is 'before_auto' and 'after_auto'.
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid', 'section']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ftd_manual_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_ftd_manual_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/manualnatrules/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDManualNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ftd_nat_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_nat_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ftd_nat_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ftd_nat_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_ftd_nat_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_nat_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ftd_nat_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_ftd_nat_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_ftd_nat_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ftd_nat_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_nat_rule  # noqa: E501

        **Retrieves list of all NAT rules (manual and auto) associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_nat_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves nat rule in given section. Allowed value is 'before_auto', 'auto' and 'after_auto'.
        :param str filter: Value is of format : <code>\"sourceInterface:name;destinationInterface:name;originalSource:name/value;<br/>originalDestination:name/value;translatedSource:name/value;translatedDestination:name/value;<br/>originalSourcePort:name/value;originalDestinationPort:name/value;translatedSourcePort:name/value;<br/>translatedDestinationPort:name/value\"</code><br/>sourceInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>destinationInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>OriginalSource: Network object configured as Orignal source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalDestination:Network object configured as Destination source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedSource:Network object configured as translated source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedDestination:Network object configured as translated Destination object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalSourcePort:Port object configured as Original Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>originalDestinationPort:Port object configured as Original Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedSourcePort:Port object configured as Translated Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedDestinationPort:Port object configured as Translated Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given\"<br/>
        :return: FTDNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ftd_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ftd_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_ftd_nat_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_ftd_nat_rule  # noqa: E501

        **Retrieves list of all NAT rules (manual and auto) associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftd_nat_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a NAT rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves nat rule in given section. Allowed value is 'before_auto', 'auto' and 'after_auto'.
        :param str filter: Value is of format : <code>\"sourceInterface:name;destinationInterface:name;originalSource:name/value;<br/>originalDestination:name/value;translatedSource:name/value;translatedDestination:name/value;<br/>originalSourcePort:name/value;originalDestinationPort:name/value;translatedSourcePort:name/value;<br/>translatedDestinationPort:name/value\"</code><br/>sourceInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>destinationInterface:SecurityZone/Interface group name (sec_zone_name1) can be given as value to fetch nat rule<br/>OriginalSource: Network object configured as Orignal source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalDestination:Network object configured as Destination source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedSource:Network object configured as translated source object name (object_name) or the value (10.1.2.3) of the object can be given<br/>translatedDestination:Network object configured as translated Destination object name (object_name) or the value (10.1.2.3) of the object can be given<br/>originalSourcePort:Port object configured as Original Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>originalDestinationPort:Port object configured as Original Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedSourcePort:Port object configured as Translated Source Port object name (http) or value of the object as port no or protocal (tcp/80) can be given<br/>translatedDestinationPort:Port object configured as Translated Destination Port object name (http) or value of the object as port no or protocal (tcp/80) can be given\"<br/>
        :return: FTDNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid', 'section', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ftd_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_ftd_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_ftd_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_ftd_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/natrules/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ftds2_s_vpn_model(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftds2_s_vpn_model(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ftds2_s_vpn_model_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ftds2_s_vpn_model_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_ftds2_s_vpn_model_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ftds2_s_vpn_model_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ftds2_s_vpn_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_ftds2_s_vpn_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_ftds2_s_vpn_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDS2SVpnModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_hit_count(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hit_count(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of access rules if set to list of rule UUIDs. If this key is not used, all access rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: HitCountListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_hit_count_with_http_info(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_hit_count_with_http_info(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of access rules if set to list of rule UUIDs. If this key is not used, all access rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: HitCountListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_hit_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `get_hit_count`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_hit_count`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_hit_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/operational/hitcounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HitCountListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_intrusion_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_intrusion_policy  # noqa: E501

        **Retrieves the intrusion policy associated with the specified ID. If no ID is specified, retrieves list of all intrusion policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_intrusion_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for intrusion policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: IntrusionPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_intrusion_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_intrusion_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_intrusion_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_intrusion_policy  # noqa: E501

        **Retrieves the intrusion policy associated with the specified ID. If no ID is specified, retrieves list of all intrusion policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_intrusion_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for intrusion policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: IntrusionPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_intrusion_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_intrusion_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_intrusion_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/intrusionpolicies/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IntrusionPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prefilter_default_action(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified prefilter control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified prefilter policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_default_action(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterDefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_prefilter_default_action_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prefilter_default_action_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_prefilter_default_action_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified prefilter control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified prefilter policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_default_action_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterDefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prefilter_default_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_prefilter_default_action`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_prefilter_default_action`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_prefilter_default_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/defaultactions/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterDefaultAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prefilter_hit_count(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_hit_count(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of prefilter rules if set to list of rule UUIDs. If this key is not used, all prefilter rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterHitCountListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_prefilter_hit_count_with_http_info(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of prefilter rules if set to list of rule UUIDs. If this key is not used, all prefilter rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param int offset: Index of first item to return.
        :param int limit: Number of items to return.
        :param bool expanded: If set to true, the GET response displays a list of objects with additional attributes.
        :return: PrefilterHitCountListContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'container_uuid', 'domain_uuid', 'offset', 'limit', 'expanded']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prefilter_hit_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `get_prefilter_hit_count`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_prefilter_hit_count`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_prefilter_hit_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'expanded' in params:
            query_params.append(('expanded', params['expanded']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/operational/hitcounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterHitCountListContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prefilter_policy(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_policy(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_prefilter_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prefilter_policy_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_prefilter_policy_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_policy_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prefilter_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_prefilter_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_prefilter_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prefilter_rule(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_rule(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a prefilter rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_prefilter_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prefilter_rule_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_prefilter_rule_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prefilter_rule_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a prefilter rule. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_snmp_config(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_snmp_config  # noqa: E501

        **Retrieves the SNMP alert object associated with the specified ID. If no ID is specified, retrieves list of all SNMP alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_snmp_config(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a SNMP alert. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: SNMPConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_snmp_config_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_snmp_config_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_snmp_config_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_snmp_config  # noqa: E501

        **Retrieves the SNMP alert object associated with the specified ID. If no ID is specified, retrieves list of all SNMP alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_snmp_config_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a SNMP alert. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: SNMPConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_snmp_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_snmp_config`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_snmp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/snmpalerts/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SNMPConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_syslog_config(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_syslog_config  # noqa: E501

        **Retrieves the syslog alert object associated with the specified ID. If no ID is specified, retrieves list of all syslog alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_syslog_config(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a syslog alert. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: SyslogConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_syslog_config_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_syslog_config_with_http_info(object_id, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_syslog_config_with_http_info(self, object_id, domain_uuid, **kwargs):  # noqa: E501
        """get_syslog_config  # noqa: E501

        **Retrieves the syslog alert object associated with the specified ID. If no ID is specified, retrieves list of all syslog alert objects.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_syslog_config_with_http_info(object_id, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a syslog alert. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: SyslogConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_syslog_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_syslog_config`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_syslog_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/syslogalerts/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyslogConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpn_advanced_settings(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_advanced_settings  # noqa: E501

        **Retrieves and modifies a Advanced settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single AdvancedSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_advanced_settings(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for Advanced settings in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnAdvancedSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpn_advanced_settings_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vpn_advanced_settings_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_vpn_advanced_settings_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_advanced_settings  # noqa: E501

        **Retrieves and modifies a Advanced settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single AdvancedSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_advanced_settings_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for Advanced settings in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnAdvancedSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpn_advanced_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_vpn_advanced_settings`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_vpn_advanced_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_vpn_advanced_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/advancedsettings/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnAdvancedSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpn_endpoint(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_endpoint(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Endpoint in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpn_endpoint_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vpn_endpoint_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_vpn_endpoint_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_endpoint_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Endpoint in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpn_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_vpn_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/endpoints/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpn_ike_settings(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_ike_settings  # noqa: E501

        **Retrieves, deletes, creates, or modifies the IKE Settings associated with the specified ID inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves Ike Settings of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_ike_settings(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Ike Settings policy in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIkeSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpn_ike_settings_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vpn_ike_settings_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_vpn_ike_settings_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_ike_settings  # noqa: E501

        **Retrieves, deletes, creates, or modifies the IKE Settings associated with the specified ID inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves Ike Settings of a topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_ike_settings_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Ike Settings policy in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIkeSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpn_ike_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_vpn_ike_settings`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_vpn_ike_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_vpn_ike_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/ikesettings/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnIkeSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpn_ip_sec_settings(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_ip_sec_settings  # noqa: E501

        **Retrieves and modifies a IPSec Proposal settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single IPSecSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_ip_sec_settings(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for IPSec Proposal settings in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIPSecSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpn_ip_sec_settings_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vpn_ip_sec_settings_with_http_info(object_id, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def get_vpn_ip_sec_settings_with_http_info(self, object_id, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """get_vpn_ip_sec_settings  # noqa: E501

        **Retrieves and modifies a IPSec Proposal settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single IPSecSettings entry of the topology.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_ip_sec_settings_with_http_info(object_id, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for IPSec Proposal settings in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIPSecSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpn_ip_sec_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `get_vpn_ip_sec_settings`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `get_vpn_ip_sec_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `get_vpn_ip_sec_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/ipsecsettings/{objectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnIPSecSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_policy(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for access control policy. (required)
        :param AccessPolicy body: Input representation of access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_policy_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_policy_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_access_policy_with_http_info(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control policy associated with the specified ID. Also, retrieves list of all access control policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_with_http_info(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for access control policy. (required)
        :param AccessPolicy body: Input representation of access control policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_access_policy`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_access_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_access_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_policy_category(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_category(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a category. (required)
        :param AccessPolicyCategory body: The input category model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_policy_category_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_policy_category_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_access_policy_category_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy_category  # noqa: E501

        **Retrieves, deletes, creates, or modifies the category associated with the specified policy ID. If no ID is specified, retrieves list of all categories associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_category_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a category. (required)
        :param AccessPolicyCategory body: The input category model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyCategory
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_policy_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_access_policy_category`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_access_policy_category`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_access_policy_category`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_access_policy_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/categories/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyCategory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_policy_inheritance_setting(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy_inheritance_setting  # noqa: E501

        **Retrieves and modifies the inheritance settings associated with specified Access Policy. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_inheritance_setting(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of the Access Policy Inheritance Setting. (required)
        :param AccessPolicyInheritanceSetting body: Payload representing the Access Policy Inheritance Setting. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyInheritanceSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_policy_inheritance_setting_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_policy_inheritance_setting_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_access_policy_inheritance_setting_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy_inheritance_setting  # noqa: E501

        **Retrieves and modifies the inheritance settings associated with specified Access Policy. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_inheritance_setting_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of the Access Policy Inheritance Setting. (required)
        :param AccessPolicyInheritanceSetting body: Payload representing the Access Policy Inheritance Setting. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyInheritanceSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_policy_inheritance_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_access_policy_inheritance_setting`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_access_policy_inheritance_setting`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_access_policy_inheritance_setting`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_access_policy_inheritance_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/inheritancesettings/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyInheritanceSetting',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_policy_logging_setting_model(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy_logging_setting_model  # noqa: E501

        **Retrieves or modifies the logging setting associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_logging_setting_model(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a logging setting. (required)
        :param AccessPolicyLoggingSettingModel body: The input default action model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyLoggingSettingModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_policy_logging_setting_model_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_policy_logging_setting_model_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_access_policy_logging_setting_model_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_policy_logging_setting_model  # noqa: E501

        **Retrieves or modifies the logging setting associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_policy_logging_setting_model_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a logging setting. (required)
        :param AccessPolicyLoggingSettingModel body: The input default action model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessPolicyLoggingSettingModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_policy_logging_setting_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_access_policy_logging_setting_model`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_access_policy_logging_setting_model`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_access_policy_logging_setting_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_access_policy_logging_setting_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/loggingsettings/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessPolicyLoggingSettingModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_rule(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_rule(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an access control rule. (required)
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_access_rule_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_rule_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an access control rule. (required)
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_access_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_access_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_default_action(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_action(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param DefaultAction body: The input default action model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: DefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_default_action_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_default_action_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_default_action_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified access control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified access control policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_action_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param DefaultAction body: The input default action model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: DefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_default_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_default_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_default_action`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_default_action`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_default_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/defaultactions/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DefaultAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ftd_auto_nat_rule(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftd_auto_nat_rule(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an Auto NAT rule. (required)
        :param FTDAutoNatRule body: The input Auto NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies auto nat rule in given section. Allowed value is 'auto'.
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ftd_auto_nat_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ftd_auto_nat_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_ftd_auto_nat_rule_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_ftd_auto_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Auto NAT rule associated with the specified ID. Also, retrieves list of all Auto NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftd_auto_nat_rule_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of an Auto NAT rule. (required)
        :param FTDAutoNatRule body: The input Auto NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies auto nat rule in given section. Allowed value is 'auto'.
        :return: FTDAutoNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid', 'section']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ftd_auto_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_ftd_auto_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_ftd_auto_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/autonatrules/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDAutoNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ftd_manual_nat_rule(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftd_manual_nat_rule(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a Manual NAT rule. (required)
        :param FTDManualNatRule body: The input Manual NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies manual nat rule in given section. Allowed value is 'before_auto' and 'after_auto'.
        :param str target_index: Creates or modifies manual nat rule at given targetIndex. It takes an integer value.
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ftd_manual_nat_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ftd_manual_nat_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_ftd_manual_nat_rule_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_ftd_manual_nat_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the Manual NAT rule associated with the specified ID. Also, retrieves list of all Manual NAT rules. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftd_manual_nat_rule_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a Manual NAT rule. (required)
        :param FTDManualNatRule body: The input Manual NAT rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :param str section: Retrieves, creates or modifies manual nat rule in given section. Allowed value is 'before_auto' and 'after_auto'.
        :param str target_index: Creates or modifies manual nat rule at given targetIndex. It takes an integer value.
        :return: FTDManualNatRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid', 'section', 'target_index']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ftd_manual_nat_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_ftd_manual_nat_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_ftd_manual_nat_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
        if 'target_index' in params:
            query_params.append(('targetIndex', params['target_index']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{containerUUID}/manualnatrules/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDManualNatRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ftd_nat_policy(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftd_nat_policy(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for NAT policy. (required)
        :param FTDNatPolicy body: Input representation of NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ftd_nat_policy_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ftd_nat_policy_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_ftd_nat_policy_with_http_info(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_ftd_nat_policy  # noqa: E501

        **Retrieves, deletes, creates, or modifies the NAT policy associated with the specified ID. Also, retrieves list of all NAT policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftd_nat_policy_with_http_info(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for NAT policy. (required)
        :param FTDNatPolicy body: Input representation of NAT policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDNatPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ftd_nat_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_ftd_nat_policy`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_ftd_nat_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_ftd_nat_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftdnatpolicies/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDNatPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ftds2_s_vpn_model(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftds2_s_vpn_model(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for FTD Site to Site VPN topology. (required)
        :param FTDS2SVpnModel body: Input representation of FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ftds2_s_vpn_model_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ftds2_s_vpn_model_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_ftds2_s_vpn_model_with_http_info(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_ftds2_s_vpn_model  # noqa: E501

        **Retrieves, deletes, creates, or modifies the FTD Site to Site VPN topology associated with the specified ID. If no ID is specified for a GET, retrieves list of all FTD Site to Site VPN topologies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ftds2_s_vpn_model_with_http_info(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for FTD Site to Site VPN topology. (required)
        :param FTDS2SVpnModel body: Input representation of FTD Site to Site VPN topology. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: FTDS2SVpnModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ftds2_s_vpn_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_ftds2_s_vpn_model`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_ftds2_s_vpn_model`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_ftds2_s_vpn_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FTDS2SVpnModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_hit_count(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_hit_count(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of access rules if set to list of rule UUIDs. If this key is not used, all access rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: HitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_hit_count_with_http_info(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_hit_count_with_http_info(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of access rules if set to list of rule UUIDs. If this key is not used, all access rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: HitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_hit_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `update_hit_count`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_hit_count`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_hit_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/operational/hitcounts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HitCount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_multiple_access_rule(self, bulk, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_multiple_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_multiple_access_rule(bulk, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_multiple_access_rule_with_http_info(bulk, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_multiple_access_rule_with_http_info(bulk, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_multiple_access_rule_with_http_info(self, bulk, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_multiple_access_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the access control rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all access rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_multiple_access_rule_with_http_info(bulk, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param AccessRule body: The input access control rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: AccessRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bulk', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_multiple_access_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bulk' is set
        if self.api_client.client_side_validation and ('bulk' not in params or
                                                       params['bulk'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `bulk` when calling `update_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_multiple_access_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_multiple_access_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/accesspolicies/{containerUUID}/accessrules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_multiple_prefilter_rule(self, bulk, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_multiple_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_multiple_prefilter_rule(bulk, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_multiple_prefilter_rule_with_http_info(bulk, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_multiple_prefilter_rule_with_http_info(bulk, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_multiple_prefilter_rule_with_http_info(self, bulk, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_multiple_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_multiple_prefilter_rule_with_http_info(bulk, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool bulk: This parameter specifies that bulk operation is being used in the query. This parameter is required for bulk rule operations. (required)
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bulk', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_multiple_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bulk' is set
        if self.api_client.client_side_validation and ('bulk' not in params or
                                                       params['bulk'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `bulk` when calling `update_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_multiple_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_multiple_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'bulk' in params:
            query_params.append(('bulk', params['bulk']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prefilter_default_action(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified prefilter control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified prefilter policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_default_action(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param PrefilterDefaultAction body: The input default action model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterDefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prefilter_default_action_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prefilter_default_action_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_prefilter_default_action_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_default_action  # noqa: E501

        **Retrieves or modifies the default action associated with the specified prefilter control policy ID and default action ID. If no default action ID is specified, retrieves list of all default actions associated with the specified prefilter policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_default_action_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a default action. (required)
        :param PrefilterDefaultAction body: The input default action model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterDefaultAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prefilter_default_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_prefilter_default_action`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_prefilter_default_action`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_prefilter_default_action`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_prefilter_default_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/defaultactions/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterDefaultAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prefilter_hit_count(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_hit_count(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of prefilter rules if set to list of rule UUIDs. If this key is not used, all prefilter rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterHitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_prefilter_hit_count_with_http_info(self, filter, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_hit_count  # noqa: E501

        **Retrieves, refreshes and clears Hit Count _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_hit_count_with_http_info(filter, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Value is of format (including quotes): <code>\"deviceId:{uuid};ids:{uuid1,uuid2,..};fetchZeroHitCount:{true|false}\"</code><br/><code>deviceId</code> is UUID of device and is a mandatory field.<br/><code>ids</code> returns hitcounts of prefilter rules if set to list of rule UUIDs. If this key is not used, all prefilter rules will be returned (Note that this is applicable only in GET and DELETE operations). <br/><code>fetchZeroHitCount</code> returns only access rules whose hit count is zero if <code>true</code> (Note that this is applicable only in GET operation and if <code>ids</code> is not used). (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterHitCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prefilter_hit_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter' is set
        if self.api_client.client_side_validation and ('filter' not in params or
                                                       params['filter'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `filter` when calling `update_prefilter_hit_count`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_prefilter_hit_count`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_prefilter_hit_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/operational/hitcounts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterHitCount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prefilter_policy(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_policy(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for prefilter policy. (required)
        :param PrefilterPolicy body: Input representation of prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prefilter_policy_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prefilter_policy_with_http_info(object_id, body, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_prefilter_policy_with_http_info(self, object_id, body, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_policy  # noqa: E501

        **Retrieves prefilter policy associated with the specified ID. Also, retrieves list of all prefilter policies. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_policy_with_http_info(object_id, body, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for prefilter policy. (required)
        :param PrefilterPolicy body: Input representation of prefilter policy. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prefilter_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_prefilter_policy`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_prefilter_policy`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_prefilter_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prefilter_rule(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_rule(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a prefilter rule. (required)
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prefilter_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prefilter_rule_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_prefilter_rule_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_prefilter_rule  # noqa: E501

        **Retrieves, deletes, creates, or modifies the prefilter rule associated with the specified policy ID and rule ID. If no ID is specified, retrieves list of all prefilter rules associated with the specified policy ID. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prefilter_rule_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Unique identifier of a prefilter rule. (required)
        :param PrefilterRule body: The input prefilter rule model. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: PrefilterRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prefilter_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_prefilter_rule`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_prefilter_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/prefilterpolicies/{containerUUID}/prefilterrules/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrefilterRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vpn_advanced_settings(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_advanced_settings  # noqa: E501

        **Retrieves and modifies a Advanced settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single AdvancedSettings entry of the topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_advanced_settings(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for Advanced settings in a Site to Site VPN topology. (required)
        :param VpnAdvancedSettings body: Input representation of Advanced settings in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnAdvancedSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_vpn_advanced_settings_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vpn_advanced_settings_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_vpn_advanced_settings_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_advanced_settings  # noqa: E501

        **Retrieves and modifies a Advanced settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single AdvancedSettings entry of the topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_advanced_settings_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for Advanced settings in a Site to Site VPN topology. (required)
        :param VpnAdvancedSettings body: Input representation of Advanced settings in a Site to Site VPN topology. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnAdvancedSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vpn_advanced_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_vpn_advanced_settings`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_vpn_advanced_settings`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_vpn_advanced_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_vpn_advanced_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/advancedsettings/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnAdvancedSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vpn_endpoint(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_endpoint(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Endpoint in a Site to Site VPN topology. (required)
        :param VpnEndpoint body: Input representation of Endpoint. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_vpn_endpoint_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vpn_endpoint_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_vpn_endpoint_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_endpoint  # noqa: E501

        **Retrieves, deletes, creates, or modifies a specific Endpoint associated with the specified ID inside a VPN Site To Site Topology. If no ID is specifid for a GET, retrieves list of all Endpoints of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_endpoint_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Endpoint in a Site to Site VPN topology. (required)
        :param VpnEndpoint body: Input representation of Endpoint. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vpn_endpoint" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_vpn_endpoint`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_vpn_endpoint`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/endpoints/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vpn_ike_settings(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_ike_settings  # noqa: E501

        **Retrieves, deletes, creates, or modifies the IKE Settings associated with the specified ID inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves Ike Settings of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_ike_settings(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Ike Settings policy in a Site to Site VPN topology. (required)
        :param VpnIkeSettings body: Input representation of Ike Settings. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIkeSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_vpn_ike_settings_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vpn_ike_settings_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_vpn_ike_settings_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_ike_settings  # noqa: E501

        **Retrieves, deletes, creates, or modifies the IKE Settings associated with the specified ID inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves Ike Settings of a topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_ike_settings_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for an Ike Settings policy in a Site to Site VPN topology. (required)
        :param VpnIkeSettings body: Input representation of Ike Settings. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIkeSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vpn_ike_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_vpn_ike_settings`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_vpn_ike_settings`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_vpn_ike_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_vpn_ike_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/ikesettings/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnIkeSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vpn_ip_sec_settings(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_ip_sec_settings  # noqa: E501

        **Retrieves and modifies a IPSec Proposal settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single IPSecSettings entry of the topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_ip_sec_settings(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for IPSec Proposal settings in a Site to Site VPN topology. (required)
        :param VpnIPSecSettings body: Input representation of IPSec Proposal settings. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIPSecSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_vpn_ip_sec_settings_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vpn_ip_sec_settings_with_http_info(object_id, body, container_uuid, domain_uuid, **kwargs)  # noqa: E501
            return data

    def update_vpn_ip_sec_settings_with_http_info(self, object_id, body, container_uuid, domain_uuid, **kwargs):  # noqa: E501
        """update_vpn_ip_sec_settings  # noqa: E501

        **Retrieves and modifies a IPSec Proposal settings inside a VPN Site To Site Topology. If no ID is specified for a GET, retrieves list containing a single IPSecSettings entry of the topology. _Check the response section for applicable examples (if any)._**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_vpn_ip_sec_settings_with_http_info(object_id, body, container_uuid, domain_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str object_id: Identifier for IPSec Proposal settings in a Site to Site VPN topology. (required)
        :param VpnIPSecSettings body: Input representation of IPSec Proposal settings. (required)
        :param str container_uuid: The container id under which this specific resource is contained. (required)
        :param str domain_uuid: Domain UUID (required)
        :return: VpnIPSecSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['object_id', 'body', 'container_uuid', 'domain_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vpn_ip_sec_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'object_id' is set
        if self.api_client.client_side_validation and ('object_id' not in params or
                                                       params['object_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `object_id` when calling `update_vpn_ip_sec_settings`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `update_vpn_ip_sec_settings`")  # noqa: E501
        # verify the required parameter 'container_uuid' is set
        if self.api_client.client_side_validation and ('container_uuid' not in params or
                                                       params['container_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `container_uuid` when calling `update_vpn_ip_sec_settings`")  # noqa: E501
        # verify the required parameter 'domain_uuid' is set
        if self.api_client.client_side_validation and ('domain_uuid' not in params or
                                                       params['domain_uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `domain_uuid` when calling `update_vpn_ip_sec_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'object_id' in params:
            path_params['objectId'] = params['object_id']  # noqa: E501
        if 'container_uuid' in params:
            path_params['containerUUID'] = params['container_uuid']  # noqa: E501
        if 'domain_uuid' in params:
            path_params['domainUUID'] = params['domain_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/fmc_config/v1/domain/{domainUUID}/policy/ftds2svpns/{containerUUID}/ipsecsettings/{objectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VpnIPSecSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
