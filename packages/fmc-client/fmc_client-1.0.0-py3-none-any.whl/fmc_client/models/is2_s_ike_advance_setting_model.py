# coding: utf-8

"""
    Cisco Firepower Management Center Open API Specification

    **Specifies the REST URLs and methods supported in the Cisco Firepower Management Center API. Refer to the version specific [REST API Quick Start Guide](https://www.cisco.com/c/en/us/support/security/defense-center/products-programming-reference-guides-list.html) for additional information.**  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: tac@cisco.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from fmc_client.configuration import Configuration


class IS2SIkeAdvanceSettingModel(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'peer_identity_validation': 'str',
        'enable_notification_on_tunnel_disconnect': 'bool',
        'threshold_to_challenge_incoming_cookies': 'int',
        'ike_keepalive_settings': 'IIkeKeepaliveSettings',
        'identity_sent_to_peer': 'str',
        'enable_aggressive_mode': 'bool',
        'cookie_challenge': 'str',
        'percentage_of_s_as_allowed_in_negotiation': 'int',
        'maximum_number_of_s_as_allowed': 'int'
    }

    attribute_map = {
        'peer_identity_validation': 'peerIdentityValidation',
        'enable_notification_on_tunnel_disconnect': 'enableNotificationOnTunnelDisconnect',
        'threshold_to_challenge_incoming_cookies': 'thresholdToChallengeIncomingCookies',
        'ike_keepalive_settings': 'ikeKeepaliveSettings',
        'identity_sent_to_peer': 'identitySentToPeer',
        'enable_aggressive_mode': 'enableAggressiveMode',
        'cookie_challenge': 'cookieChallenge',
        'percentage_of_s_as_allowed_in_negotiation': 'percentageOfSAsAllowedInNegotiation',
        'maximum_number_of_s_as_allowed': 'maximumNumberOfSAsAllowed'
    }

    def __init__(self, peer_identity_validation=None, enable_notification_on_tunnel_disconnect=None, threshold_to_challenge_incoming_cookies=None, ike_keepalive_settings=None, identity_sent_to_peer=None, enable_aggressive_mode=None, cookie_challenge=None, percentage_of_s_as_allowed_in_negotiation=None, maximum_number_of_s_as_allowed=None, _configuration=None):  # noqa: E501
        """IS2SIkeAdvanceSettingModel - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._peer_identity_validation = None
        self._enable_notification_on_tunnel_disconnect = None
        self._threshold_to_challenge_incoming_cookies = None
        self._ike_keepalive_settings = None
        self._identity_sent_to_peer = None
        self._enable_aggressive_mode = None
        self._cookie_challenge = None
        self._percentage_of_s_as_allowed_in_negotiation = None
        self._maximum_number_of_s_as_allowed = None
        self.discriminator = None

        if peer_identity_validation is not None:
            self.peer_identity_validation = peer_identity_validation
        if enable_notification_on_tunnel_disconnect is not None:
            self.enable_notification_on_tunnel_disconnect = enable_notification_on_tunnel_disconnect
        if threshold_to_challenge_incoming_cookies is not None:
            self.threshold_to_challenge_incoming_cookies = threshold_to_challenge_incoming_cookies
        if ike_keepalive_settings is not None:
            self.ike_keepalive_settings = ike_keepalive_settings
        if identity_sent_to_peer is not None:
            self.identity_sent_to_peer = identity_sent_to_peer
        if enable_aggressive_mode is not None:
            self.enable_aggressive_mode = enable_aggressive_mode
        if cookie_challenge is not None:
            self.cookie_challenge = cookie_challenge
        if percentage_of_s_as_allowed_in_negotiation is not None:
            self.percentage_of_s_as_allowed_in_negotiation = percentage_of_s_as_allowed_in_negotiation
        if maximum_number_of_s_as_allowed is not None:
            self.maximum_number_of_s_as_allowed = maximum_number_of_s_as_allowed

    @property
    def peer_identity_validation(self):
        """Gets the peer_identity_validation of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The peer_identity_validation of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: str
        """
        return self._peer_identity_validation

    @peer_identity_validation.setter
    def peer_identity_validation(self, peer_identity_validation):
        """Sets the peer_identity_validation of this IS2SIkeAdvanceSettingModel.


        :param peer_identity_validation: The peer_identity_validation of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: str
        """
        allowed_values = ["DO_NOT_CHECK", "REQUIRED", "IF_SUPPORTED_BY_CERT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                peer_identity_validation not in allowed_values):
            raise ValueError(
                "Invalid value for `peer_identity_validation` ({0}), must be one of {1}"  # noqa: E501
                .format(peer_identity_validation, allowed_values)
            )

        self._peer_identity_validation = peer_identity_validation

    @property
    def enable_notification_on_tunnel_disconnect(self):
        """Gets the enable_notification_on_tunnel_disconnect of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The enable_notification_on_tunnel_disconnect of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: bool
        """
        return self._enable_notification_on_tunnel_disconnect

    @enable_notification_on_tunnel_disconnect.setter
    def enable_notification_on_tunnel_disconnect(self, enable_notification_on_tunnel_disconnect):
        """Sets the enable_notification_on_tunnel_disconnect of this IS2SIkeAdvanceSettingModel.


        :param enable_notification_on_tunnel_disconnect: The enable_notification_on_tunnel_disconnect of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: bool
        """

        self._enable_notification_on_tunnel_disconnect = enable_notification_on_tunnel_disconnect

    @property
    def threshold_to_challenge_incoming_cookies(self):
        """Gets the threshold_to_challenge_incoming_cookies of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The threshold_to_challenge_incoming_cookies of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: int
        """
        return self._threshold_to_challenge_incoming_cookies

    @threshold_to_challenge_incoming_cookies.setter
    def threshold_to_challenge_incoming_cookies(self, threshold_to_challenge_incoming_cookies):
        """Sets the threshold_to_challenge_incoming_cookies of this IS2SIkeAdvanceSettingModel.


        :param threshold_to_challenge_incoming_cookies: The threshold_to_challenge_incoming_cookies of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: int
        """

        self._threshold_to_challenge_incoming_cookies = threshold_to_challenge_incoming_cookies

    @property
    def ike_keepalive_settings(self):
        """Gets the ike_keepalive_settings of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The ike_keepalive_settings of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: IIkeKeepaliveSettings
        """
        return self._ike_keepalive_settings

    @ike_keepalive_settings.setter
    def ike_keepalive_settings(self, ike_keepalive_settings):
        """Sets the ike_keepalive_settings of this IS2SIkeAdvanceSettingModel.


        :param ike_keepalive_settings: The ike_keepalive_settings of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: IIkeKeepaliveSettings
        """

        self._ike_keepalive_settings = ike_keepalive_settings

    @property
    def identity_sent_to_peer(self):
        """Gets the identity_sent_to_peer of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The identity_sent_to_peer of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: str
        """
        return self._identity_sent_to_peer

    @identity_sent_to_peer.setter
    def identity_sent_to_peer(self, identity_sent_to_peer):
        """Sets the identity_sent_to_peer of this IS2SIkeAdvanceSettingModel.


        :param identity_sent_to_peer: The identity_sent_to_peer of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: str
        """
        allowed_values = ["IP_ADDRESS", "HOST_NAME", "AUTO_OR_DN"]  # noqa: E501
        if (self._configuration.client_side_validation and
                identity_sent_to_peer not in allowed_values):
            raise ValueError(
                "Invalid value for `identity_sent_to_peer` ({0}), must be one of {1}"  # noqa: E501
                .format(identity_sent_to_peer, allowed_values)
            )

        self._identity_sent_to_peer = identity_sent_to_peer

    @property
    def enable_aggressive_mode(self):
        """Gets the enable_aggressive_mode of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The enable_aggressive_mode of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: bool
        """
        return self._enable_aggressive_mode

    @enable_aggressive_mode.setter
    def enable_aggressive_mode(self, enable_aggressive_mode):
        """Sets the enable_aggressive_mode of this IS2SIkeAdvanceSettingModel.


        :param enable_aggressive_mode: The enable_aggressive_mode of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: bool
        """

        self._enable_aggressive_mode = enable_aggressive_mode

    @property
    def cookie_challenge(self):
        """Gets the cookie_challenge of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The cookie_challenge of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: str
        """
        return self._cookie_challenge

    @cookie_challenge.setter
    def cookie_challenge(self, cookie_challenge):
        """Sets the cookie_challenge of this IS2SIkeAdvanceSettingModel.


        :param cookie_challenge: The cookie_challenge of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: str
        """
        allowed_values = ["CUSTOM", "ALWAYS", "NEVER"]  # noqa: E501
        if (self._configuration.client_side_validation and
                cookie_challenge not in allowed_values):
            raise ValueError(
                "Invalid value for `cookie_challenge` ({0}), must be one of {1}"  # noqa: E501
                .format(cookie_challenge, allowed_values)
            )

        self._cookie_challenge = cookie_challenge

    @property
    def percentage_of_s_as_allowed_in_negotiation(self):
        """Gets the percentage_of_s_as_allowed_in_negotiation of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The percentage_of_s_as_allowed_in_negotiation of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: int
        """
        return self._percentage_of_s_as_allowed_in_negotiation

    @percentage_of_s_as_allowed_in_negotiation.setter
    def percentage_of_s_as_allowed_in_negotiation(self, percentage_of_s_as_allowed_in_negotiation):
        """Sets the percentage_of_s_as_allowed_in_negotiation of this IS2SIkeAdvanceSettingModel.


        :param percentage_of_s_as_allowed_in_negotiation: The percentage_of_s_as_allowed_in_negotiation of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: int
        """

        self._percentage_of_s_as_allowed_in_negotiation = percentage_of_s_as_allowed_in_negotiation

    @property
    def maximum_number_of_s_as_allowed(self):
        """Gets the maximum_number_of_s_as_allowed of this IS2SIkeAdvanceSettingModel.  # noqa: E501


        :return: The maximum_number_of_s_as_allowed of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :rtype: int
        """
        return self._maximum_number_of_s_as_allowed

    @maximum_number_of_s_as_allowed.setter
    def maximum_number_of_s_as_allowed(self, maximum_number_of_s_as_allowed):
        """Sets the maximum_number_of_s_as_allowed of this IS2SIkeAdvanceSettingModel.


        :param maximum_number_of_s_as_allowed: The maximum_number_of_s_as_allowed of this IS2SIkeAdvanceSettingModel.  # noqa: E501
        :type: int
        """

        self._maximum_number_of_s_as_allowed = maximum_number_of_s_as_allowed

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(IS2SIkeAdvanceSettingModel, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, IS2SIkeAdvanceSettingModel):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, IS2SIkeAdvanceSettingModel):
            return True

        return self.to_dict() != other.to_dict()
