Metadata-Version: 2.1
Name: lambdarado
Version: 0.1.0
Summary: Universal entry point for Docker images containing a WSGI app for the AWS Lambda.
Home-page: https://github.com/rtmigo/lambdarado_py
Author: Art—ëm IG
Author-email: ortemeo@gmail.com
License: MIT
Description: Universal entry point for Docker images containing a Flask application for the
        AWS Lambda serverless platform.
        
        Putting together:
        
        - A web application written in Python that is compliant with the
          [WSGI standard](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface).
          Currently, only **Flask** is supported.
        - A [Docker image](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html)
          that contains the application code and dependencies
        - AWS Lambda to run the code contained in the Docker image
        - AWS API Gateway, that broadcasts web requests to and from your Lambda function
        
        # What it does
        
        The package runs the relevant code depending on where it runs.
        
        On the local computer, this is the debug server, serving requests to
        `127.0.0.1` right in the browser.
        
        In the AWS cloud, this is the handler that passes Gateway requests to and from
        the WSGI application.
        
        # Install
        
        ``` bash
        $ pip3 install lambdarado 
        ```
        
        # Configure
        
        #### Dockerfile:
        
        ``` Dockerfile
        FROM public.ecr.aws/lambda/python:3.8
        
        # ... here should be the code that creates the image ...
        
        ENTRYPOINT ["python", "main.py"]
        ```
        
        #### main.py
        
        ``` python3
        import lambdarado import start
        
        def get_app():
          # this method must return WSGI app, e.g. Flask
          from my_app_module import app
          return app 
          
        start(get_app)
        ```
        
        The `main.py` file will be imported *twice* when starting the server in AWS. 
        The `get_app` method will only run *once*. Therefore, it is worth making sure 
        that the application is initialized only when you call `get_app`.
        
        # Run
        
        Local debug server
        ------------------
        
        Running shell command on development machine:
        
        ```
        $ python3 main.py
        ```
        
        This will start Werkzeug server listening to http://127.0.0.1:5000.
        
        
        Local debug server in Docker
        ----------------------------
        
        Command-line:
        
        ``` bash
        $ docker run -p 6000:5000 docker-image-name
        ```
        
        This will start Werkzeug server listening to http://0.0.0.0:5000
        (inside the docker). The server is accessible as http://127.0.0.1:6000
        from the host machine.
        
        
        Production server on AWS Lambda
        -------------------------------
        
        After deploying the same image as a Lambda function, it will serve the requests
        to the AWS Gateway with your `app`.
        
        - You should connect the AWS Gateway to your Lambda function. For the function
          to receive all HTTP requests, you may need to redirect the `/{proxy+}` route
          to the function and make `lambda:InvokeFunction` policy less restrictive
        
        Under the hood:
        
        - The [awslambdaric](https://pypi.org/project/awslambdaric/) will receive
          requests from and send requests to the Lambda service
        - The [apig_wsgi](https://pypi.org/project/apig-wsgi/) will translate requests
          received by `awslambdaric` from the AWS Gateway. So your application doesn't
          have to handle calls from the gateway directly. For the application, requests
          will look like normal HTTP
        
        
Keywords: amazon,aws,lambda,function,entrypoint,docker,image,container,wsgi,flask,http,api,gateway
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Operating System :: POSIX
Description-Content-Type: text/markdown
