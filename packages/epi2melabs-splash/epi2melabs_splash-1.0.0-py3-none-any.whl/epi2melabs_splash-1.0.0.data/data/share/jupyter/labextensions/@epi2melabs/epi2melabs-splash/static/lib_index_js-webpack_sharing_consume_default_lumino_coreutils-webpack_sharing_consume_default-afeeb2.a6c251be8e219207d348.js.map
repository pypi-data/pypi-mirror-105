{"version":3,"sources":["webpack://@epi2melabs/epi2melabs-splash/./lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAA8D;AAClB;AAC5C,W;AACA;AACA,IAAI;AACoD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAa;AAC3B;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA;AACA;AACA,yBAAyB,wDAAM;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,qEAAmB,EAAE,wBAAwB;AACjE,oBAAoB,mEAAiB,EAAE,2BAA2B;AAClE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS,GAAG,kDAAkD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA,iEAAe,MAAM,EAAC;AACtB,iC","file":"lib_index_js-webpack_sharing_consume_default_lumino_coreutils-webpack_sharing_consume_default-afeeb2.a6c251be8e219207d348.js","sourcesContent":["import { Dialog, ISplashScreen, } from '@jupyterlab/apputils';\nimport { Throttler } from '@lumino/polling';\n// import { \n//   ITranslator \n// } from '@jupyterlab/translation';\nimport { DisposableDelegate } from '@lumino/disposable';\n/**\n * The interval in milliseconds before recover options appear during splash.\n */\nconst SPLASH_RECOVER_TIMEOUT = 12000;\n/**\n * The command IDs used by the apputils plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.loadState = 'apputils:load-statedb';\n    CommandIDs.print = 'apputils:print';\n    CommandIDs.reset = 'apputils:reset';\n    CommandIDs.resetOnLoad = 'apputils:reset-on-load';\n    CommandIDs.runFirstEnabled = 'apputils:run-first-enabled';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A splash screen for epi2melabs\n */\nconst splash = {\n    id: '@epi2melabs/epi2melabs-splash:plugin',\n    autoStart: true,\n    // requires: [ITranslator],\n    provides: ISplashScreen,\n    activate: (app\n    // translator: ITranslator\n    ) => {\n        // const trans = translator.load('jupyterlab');\n        const { commands, restored } = app;\n        const splash = document.createElement('div');\n        splash.id = 'epi2melabs-splash';\n        const logo = document.createElement('div');\n        logo.id = 'epi2melabs-logo';\n        splash.appendChild(logo);\n        const graphic = document.createElement('div');\n        logo.appendChild(graphic);\n        graphic.className = 'logoGraphic';\n        const graphicTop = document.createElement('div');\n        graphic.appendChild(graphicTop);\n        graphicTop.className = 'graphicTop';\n        const graphicMid = document.createElement('div');\n        graphic.appendChild(graphicMid);\n        graphicMid.className = 'graphicMid';\n        const graphicBot = document.createElement('div');\n        graphic.appendChild(graphicBot);\n        graphicBot.className = 'graphicBot';\n        const text = document.createElement('div');\n        logo.appendChild(text);\n        text.className = 'logoText';\n        const epi2me = document.createElement('h1');\n        epi2me.innerHTML = 'EPI2ME';\n        text.appendChild(epi2me);\n        const labs = document.createElement('h2');\n        labs.innerHTML = 'Labs';\n        text.appendChild(labs);\n        // Create debounced recovery dialog function.\n        let dialog;\n        const recovery = new Throttler(async () => {\n            if (dialog) {\n                return;\n            }\n            dialog = new Dialog({\n                title: 'Loading...',\n                body: `The loading screen is taking a long time. \nWould you like to clear the workspace or keep waiting?`,\n                buttons: [\n                    Dialog.cancelButton({ label: 'Keep Waiting' }),\n                    Dialog.warnButton({ label: 'Clear Workspace' })\n                ]\n            });\n            try {\n                const result = await dialog.launch();\n                dialog.dispose();\n                dialog = null;\n                if (result.button.accept && commands.hasCommand(CommandIDs.reset)) {\n                    return commands.execute(CommandIDs.reset);\n                }\n                // Re-invoke the recovery timer in the next frame.\n                requestAnimationFrame(() => {\n                    // Because recovery can be stopped, handle invocation rejection.\n                    void recovery.invoke().catch(_ => undefined);\n                });\n            }\n            catch (error) {\n                /* no-op */\n            }\n        }, { limit: SPLASH_RECOVER_TIMEOUT, edge: 'trailing' });\n        // Return ISplashScreen.\n        let splashCount = 0;\n        return {\n            show: () => {\n                splash.classList.remove('splash-fade');\n                splashCount++;\n                console.log('adding');\n                document.body.appendChild(splash);\n                // Because recovery can be stopped, handle invocation rejection.\n                void recovery.invoke().catch(_ => undefined);\n                return new DisposableDelegate(async () => {\n                    await restored;\n                    if (--splashCount === 0) {\n                        void recovery.stop();\n                        if (dialog) {\n                            dialog.dispose();\n                            dialog = null;\n                        }\n                        splash.classList.add('splash-fade');\n                        window.setTimeout(() => {\n                            document.body.removeChild(splash);\n                        }, 200);\n                    }\n                });\n            }\n        };\n    },\n};\nexport default splash;\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}