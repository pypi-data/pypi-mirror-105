import tbridge
from numpy import trapz, copy, isnan, isinf, log10, arange, max
from scipy.interpolate import interp1d
from scipy.signal import savgol_filter


def get_half_light_radius(x, y):
    """ Obtains the index of the ellipse whose semimajor axis is at the half-light radius."""
    # Estimates the half-light radius for a given profile.

    half_light = trapz(y, x) / 2
    best_sec = 0     # Light contained in given section
    best_index = 0
    for index in range(0, len(x)):
        sec = trapz(y[:index], x[:index])
        if abs(sec - half_light) < abs(best_sec - half_light):
            best_sec, best_index = sec, index
    return best_index, x[best_index]


def sb_to_i(sb, m_0=27, a_pix=0.168**2):
    """ Convert a given surface brightness to an intensity. """
    exponential = (sb - m_0) / -2.5
    return a_pix * (10 ** exponential)


def adjust_profile(x, y, clean=False, shift=0.00):
    # hlr_index, hlr_value = get_half_light_radius(x, y)

    x_new, y_new = copy(x), copy(y)

    y_new = -2.5 * log10((y + shift) / (0.168 ** 2)) + 27

    if clean:
        x_clean, y_clean = [], []
        for n in range(0, len(x_new)):
            if isnan(y_new[n]) or isinf(y_new[n]):
                continue
            else:
                x_clean.append(x_new[n])
                y_clean.append(y_new[n])
        profile_adj = interp1d(x_clean, y_clean, bounds_error=False, fill_value=max(y_clean))

        return x_new, profile_adj(x_new)

    else:
        return x_new, y_new


from matplotlib import pyplot as plt


def cutoff_values(bare, bgadded, min_val=3):
    """
    Generate a set of cutoff values based on a given set of median data. This data is generated by
    tbridge.load_median_info() under tbridge.medians.
    :param median_data:
    :return:
    """

    sma = bare["MED_SMA"]

    low_bare_1sig = interp1d(bare["L_1SIG"][0], bare["L_1SIG"][1],
                                       bounds_error=False, fill_value='interpolate')
    high_bare_1sig = interp1d(bare["U_1SIG"][0], bare["U_1SIG"][1],
                                        bounds_error=False, fill_value='interpolate')

    low_bgadded_1sig = interp1d(bgadded["L_1SIG"][0], bgadded["L_1SIG"][1],
                                       bounds_error=False, fill_value='interpolate')
    high_bgadded_1sig = interp1d(bgadded["U_1SIG"][0], bgadded["U_1SIG"][1],
                                        bounds_error=False, fill_value='interpolate')

    low_bare_3sig = interp1d(bare["L_3SIG"][0], bare["L_3SIG"][1],
                             bounds_error=False, fill_value='interpolate')
    high_bare_3sig = interp1d(bare["U_3SIG"][0], bare["U_3SIG"][1],
                              bounds_error=False, fill_value='interpolate')

    low_bgadded_3sig = interp1d(bgadded["L_3SIG"][0], bgadded["L_3SIG"][1],
                                bounds_error=False, fill_value='interpolate')
    high_bgadded_3sig = interp1d(bgadded["U_3SIG"][0], bgadded["U_3SIG"][1],
                                 bounds_error=False, fill_value='interpolate')

    low_bare_5sig = interp1d(bare["L_5SIG"][0], bare["L_5SIG"][1],
                             bounds_error=False, fill_value='interpolate')
    high_bare_5sig = interp1d(bare["U_5SIG"][0], bare["U_5SIG"][1],
                              bounds_error=False, fill_value='interpolate')

    low_bgadded_5sig = interp1d(bgadded["L_5SIG"][0], bgadded["L_5SIG"][1],
                                bounds_error=False, fill_value='interpolate')
    high_bgadded_5sig = interp1d(bgadded["U_5SIG"][0], bgadded["U_5SIG"][1],
                                 bounds_error=False, fill_value='interpolate')

    sma_fine = arange(min_val, max(sma), max(sma) / 1000)

    cutoff_1 = overlap(sma_fine, low_bare_1sig, high_bare_1sig, low_bgadded_1sig, high_bgadded_1sig)
    cutoff_3 = overlap(sma_fine, low_bare_3sig, high_bare_3sig, low_bgadded_3sig, high_bgadded_3sig)
    cutoff_5 = overlap(sma_fine, low_bare_5sig, high_bare_5sig, low_bgadded_5sig, high_bgadded_5sig)

    print(cutoff_1, cutoff_3, cutoff_5)

    # plt.fill_between(sma, low_bare_1sig(sma), high_bare_1sig(sma), color="red", alpha=0.8)
    # plt.fill_between(sma, low_bare_3sig(sma), high_bare_3sig(sma), color="red", alpha=0.5)
    plt.fill_between(sma, low_bare_5sig(sma), high_bare_5sig(sma), color="red", alpha=0.3)

    # plt.fill_between(sma, low_bgadded_1sig(sma), high_bgadded_1sig(sma), color="blue", alpha=0.8)
    # plt.fill_between(sma, low_bgadded_3sig(sma), high_bgadded_3sig(sma), color="blue", alpha=0.5)
    plt.fill_between(sma, low_bgadded_5sig(sma), high_bgadded_5sig(sma), color="blue", alpha=0.3)

    # plt.axvline(cutoff_1)
    # plt.axvline(cutoff_3)
    plt.axvline(cutoff_5)

    plt.show()

    return None


def overlap(sma, low_1, high_1, low_2, high_2, threshold=1):
    """
    Tests for non_overlap between array sets 1 and 2
    :param sma: Array of test parameters, preferably a numpy arange object
    :param low_1: scipy.interpolate.interp1d object
    :param high_1: ""           ""          ""
    :param low_2:  ""           ""          ""
    :param high_2: ""           ""          ""
    :param threshold: How many consecutive times you see non-overlap between the two profiles.
    :return:
    """
    count = 0
    for i in sma:
        overlapping = not ((high_2(i) < low_1(i)) or (low_2(i) > high_1(i)))
        if overlapping:
            count = 0
        if count == threshold:
            break
        count += 1

    # plt.fill_between(sma, low_1(sma), high_1(sma), color="red", alpha=0.8)
    # plt.fill_between(sma, low_2(sma), high_2(sma), color="blue", alpha=0.8)
    # plt.show()
    return i


def smooth(arr, window=9, poly=1, iterations=2):
    arr = copy(arr)
    for i in range(iterations):
        arr = savgol_filter(arr, window_length=window, polyorder=poly)

    return arr
