
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>masci_tools.io.parsers.kkrimp_parser_functions &#8212; Masci-tools 0.2 documentation</title>
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Masci-tools 0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for masci_tools.io.parsers.kkrimp_parser_functions</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">#use print(&#39;message&#39;) instead of print &#39;message&#39; in python 2.7 as well:</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for the impurity caluclation plugin and its workflows</span>
<span class="sd">&quot;&quot;&quot;</span>
         
<span class="n">__copyright__</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;Copyright (c), 2018, Forschungszentrum Jülich GmbH,&quot;</span>
                 <span class="s2">&quot;IAS-1/PGI-1, Germany. All rights reserved.&quot;</span><span class="p">)</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;MIT license, see LICENSE.txt file&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.3&quot;</span>
<span class="n">__contributors__</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;Philipp Rüßmann&quot;</span><span class="p">,</span> 
                    <span class="sa">u</span><span class="s2">&quot;Fabian Bertoldo&quot;</span><span class="p">)</span>




<div class="viewcode-block" id="modify_potential"><a class="viewcode-back" href="../../../../module_guide/code.html#masci_tools.io.parsers.kkrimp_parser_functions.modify_potential">[docs]</a><span class="k">class</span> <span class="nc">modify_potential</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for old modify potential script, ported from modify_potential script, initially by D. Bauer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">_check_potstart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">str1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;pot&#39;</span><span class="p">,</span> <span class="n">shape_ver</span><span class="o">=</span><span class="s1">&#39;new&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;shape&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shape_ver</span><span class="o">==</span><span class="s1">&#39;new&#39;</span><span class="p">:</span>
                <span class="n">check1</span><span class="o">=</span><span class="s1">&#39;Shape number&#39;</span> <span class="ow">in</span> <span class="n">str1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">check1</span><span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span><span class="o">==</span><span class="mi">11</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check1</span><span class="o">=</span><span class="s1">&#39;exc:&#39;</span> <span class="ow">in</span> <span class="n">str1</span>
        <span class="k">return</span> <span class="n">check1</span>
        
    <span class="k">def</span> <span class="nf">_read_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="c1">#print(filepath)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="s1">&#39;shapefun&#39;</span> <span class="ow">in</span> <span class="n">filepath</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;shape&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;pot&#39;</span>
        
        <span class="c1">#print(mode, len(data))</span>
            
        <span class="c1"># read file</span>
        <span class="n">index1</span><span class="o">=</span><span class="p">[];</span><span class="n">index2</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_potstart</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">):</span>
            <span class="n">index1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="n">index2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">index2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># read shapefun if old style is used</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;shape&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">index1</span><span class="o">=</span><span class="p">[];</span><span class="n">index2</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_potstart</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">shape_ver</span><span class="o">=</span><span class="s1">&#39;old&#39;</span><span class="p">):</span>
                    <span class="n">index1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="n">index2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">index2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
           
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        print(index1)</span>
<span class="sd">        print(index2)</span>
<span class="sd">        </span>
<span class="sd">        print(&#39;Potential file read&#39;)</span>
<span class="sd">        print(&#39;found %i potentials in file&#39;%len(index1))</span>
<span class="sd">        print(&#39;&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">data</span>

<div class="viewcode-block" id="modify_potential.shapefun_from_scoef"><a class="viewcode-back" href="../../../../module_guide/code.html#masci_tools.io.parsers.kkrimp_parser_functions.modify_potential.shapefun_from_scoef">[docs]</a>    <span class="k">def</span> <span class="nf">shapefun_from_scoef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scoefpath</span><span class="p">,</span> <span class="n">shapefun_path</span><span class="p">,</span> <span class="n">atom2shapes</span><span class="p">,</span> <span class="n">shapefun_new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read shapefun and create impurity shapefun using scoef info and shapes array</span>
<span class="sd">        </span>
<span class="sd">        :param scoefpath: absolute path to scoef file</span>
<span class="sd">        :param shapefun_path: absolute path to input shapefun file</span>
<span class="sd">        :param shapes: shapes array for mapping between atom index and shapefunction index</span>
<span class="sd">        :param shapefun_new: absolute path to output shapefun file to which the new shapefunction will be written</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_input</span><span class="p">(</span><span class="n">shapefun_path</span><span class="p">)</span>
        
        <span class="n">order</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index1</span><span class="p">))</span>
               
        <span class="n">natomtemp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">scoefpath</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">filedata</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">scoefpath</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="n">natomtemp</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">listnew</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">filedata</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">listnew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom2shapes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">3</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">listnew</span>
        
        <span class="n">datanew</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)):</span>
          <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">index2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span>  <span class="p">):</span>
            <span class="n">datanew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            
        <span class="c1"># add header to shapefun_new</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">datanew</span>
        <span class="n">datanew</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">datanew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;   </span><span class="si">%i</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)))</span>
        <span class="n">datanew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;  1.000000000000E+00</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">datanew</span> <span class="o">+=</span> <span class="n">tmp</span>
        <span class="nb">open</span><span class="p">(</span><span class="n">shapefun_new</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">datanew</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="modify_potential.neworder_potential"><a class="viewcode-back" href="../../../../module_guide/code.html#masci_tools.io.parsers.kkrimp_parser_functions.modify_potential.neworder_potential">[docs]</a>    <span class="k">def</span> <span class="nf">neworder_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">potfile_in</span><span class="p">,</span> <span class="n">potfile_out</span><span class="p">,</span> <span class="n">neworder</span><span class="p">,</span> <span class="n">potfile_2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace_from_pot2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read potential file and new potential using a list describing the order of the new potential.</span>
<span class="sd">        If a second potential is given as input together with an index list, then the corresponding of </span>
<span class="sd">        the output potential are overwritten with positions from the second input potential.</span>
<span class="sd">        </span>
<span class="sd">        :param potfile_in: absolute path to input potential</span>
<span class="sd">        :type potfile_in: str</span>
<span class="sd">        :param potfile_out: absolute path to output potential</span>
<span class="sd">        :type potfile_out: str</span>
<span class="sd">        :param neworder: list after which output potential is constructed from input potential</span>
<span class="sd">        :type neworder: list</span>
<span class="sd">        :param potfile_2: optional, absolute path to second potential file if </span>
<span class="sd">            positions in new list of potentials shall be replaced by positions of </span>
<span class="sd">            second potential, requires *replace_from_pot* to be given as well</span>
<span class="sd">        :type potfile_2: str</span>
<span class="sd">        :param replace_from_pot: optional, list containing tuples of (position </span>
<span class="sd">            in newlist that is to be replaced, position in pot2 with which position </span>
<span class="sd">            is replaced)</span>
<span class="sd">        :type replace_from_pot: list</span>
<span class="sd">        </span>
<span class="sd">        :usage:</span>
<span class="sd">            1. modify_potential().neworder_potential(&lt;path_to_input_pot&gt;, &lt;path_to_output_pot&gt;, [])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">shape</span>
        
        <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_input</span><span class="p">(</span><span class="n">potfile_in</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">potfile_2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index12</span><span class="p">,</span> <span class="n">index22</span><span class="p">,</span> <span class="n">data2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_input</span><span class="p">(</span><span class="n">potfile_2</span><span class="p">)</span>
            <span class="c1"># check if also replace_from_pot2 is given correctly</span>
            <span class="k">if</span> <span class="n">replace_from_pot2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;replace_from_pot2 not given&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">replace_from_pot2</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">replace_from_pot2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">replace_from_pot2</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;replace_from_pot2 needs to be a 2D array!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">replace_from_pot2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;replace_from_pot2 given but potfile_2 not given&#39;</span><span class="p">)</span>
        
        <span class="c1"># set order in which potential file is written</span>
        <span class="c1"># ensure that numbers are integers:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">neworder</span><span class="p">]</span>
                
        <span class="n">datanew</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)):</span>
            <span class="c1"># check if new position is replaced with position from old pot</span>
            <span class="k">if</span> <span class="n">replace_from_pot2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">replace_from_pot2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">replace_index</span> <span class="o">=</span> <span class="n">replace_from_pot2</span><span class="p">[</span><span class="n">replace_from_pot2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index12</span><span class="p">[</span><span class="n">replace_index</span><span class="p">],</span> <span class="n">index22</span><span class="p">[</span><span class="n">replace_index</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="p">):</span>
                        <span class="n">datanew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data2</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># otherwise take new potntial according to input list</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index1</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">index2</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span> <span class="p">):</span>
                        <span class="n">datanew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        
        <span class="c1"># write out new potential</span>
        <span class="nb">open</span><span class="p">(</span><span class="n">potfile_out</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">datanew</span><span class="p">)</span></div></div>
        
        
        
        
<div class="viewcode-block" id="kkrimp_parser_functions"><a class="viewcode-back" href="../../../../module_guide/code.html#masci_tools.io.parsers.kkrimp_parser_functions.kkrimp_parser_functions">[docs]</a><span class="k">class</span> <span class="nc">kkrimp_parser_functions</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class of parser functions for KKRimp calculation</span>
<span class="sd">    </span>
<span class="sd">    :usage: success, msg_list, out_dict = parse_kkrimp_outputfile().parse_kkrimp_outputfile(out_dict, files)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">### some helper functions ###</span>
    
    <span class="k">def</span> <span class="nf">_get_econt_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_log</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        extract energy contour information from out_log file</span>
<span class="sd">        :param out_log: file that is parsed</span>
<span class="sd">        :retuns: econt (dict), dictionary containing the energy contour info</span>
<span class="sd">        :note: econt contains the following keys</span>
<span class="sd">            * &#39;emin&#39;, bottom of energy contour</span>
<span class="sd">            * &#39;Nepts&#39;, number of points in energy contour</span>
<span class="sd">            * &#39;epts&#39;, list of complex valued energy points</span>
<span class="sd">            * &#39;weights&#39;, list of complex valued weights for energy integration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_log</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">econt</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;[read_energy] number of energy points&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="n">econt</span><span class="p">[</span><span class="s1">&#39;Nepts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;energies and weights are:&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ie</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">econt</span><span class="p">[</span><span class="s1">&#39;Nepts&#39;</span><span class="p">]):</span>
                <span class="n">tmpline</span> <span class="o">=</span> <span class="n">tmptxt</span><span class="p">[</span><span class="n">itmp</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">ie</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">tmpline</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmpline</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmpline</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmpline</span><span class="p">[</span><span class="mi">3</span><span class="p">])])</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">econt</span><span class="p">[</span><span class="s1">&#39;epts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">econt</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">econt</span><span class="p">[</span><span class="s1">&#39;emin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">econt</span>
    
    
    <span class="k">def</span> <span class="nf">_get_scfinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        extract scf infos (nunmber of iterations, max number of iterations, mixing info) from file</span>
<span class="sd">        :param file:</span>
<span class="sd">        :returns: niter (int), nitermax (int), converged (bool), nmax_reached (bool), mixinfo (dict)</span>
<span class="sd">        :note: mixinfo contains information on mixing scheme and mixing factor used in the calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># get rms and number of iterations</span>
        <span class="n">itmp</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">rms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;average rms-error&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">niter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">rms</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get max number of scf steps</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;SCFSTEPS&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nitermax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get qbound</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;QBOUND&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">qbound</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get imix</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;IMIX&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">imix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get mixfac</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;MIXFAC&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mixfac</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># get fcm</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;FCM&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fcm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># set mixinfo</span>
        <span class="n">mixinfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">imix</span><span class="p">,</span> <span class="n">mixfac</span><span class="p">,</span> <span class="n">qbound</span><span class="p">,</span> <span class="n">fcm</span><span class="p">]</span>
        <span class="c1"># set converged and nmax_reached logicals</span>
        <span class="n">converged</span><span class="p">,</span> <span class="n">nmax_reached</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">nitermax</span><span class="o">==</span><span class="n">niter</span><span class="p">:</span> <span class="n">nmax_reached</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">rms</span><span class="o">&lt;</span><span class="n">qbound</span><span class="p">:</span> <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># return values</span>
        <span class="k">return</span> <span class="n">niter</span><span class="p">,</span> <span class="n">nitermax</span><span class="p">,</span> <span class="n">converged</span><span class="p">,</span> <span class="n">nmax_reached</span><span class="p">,</span> <span class="n">mixinfo</span>
    
    
    <span class="k">def</span> <span class="nf">_get_newsosol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if spin orbit coupling solver is used</span>
<span class="sd">        :param file: absolute path to out_log.000.txt of KKRimp calculation</span>
<span class="sd">        :returns: True(False) if SOC solver is (not) used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;Spin orbit coupling used?&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">itmp</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">newsosol</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newsosol</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">newsosol</span>
    
    
    <span class="k">def</span> <span class="nf">_get_natom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract number of atoms in impurity cluster</span>
<span class="sd">        :param file: file that is parsed to find number of atoms</span>
<span class="sd">        :returns: natom (int), number of atoms in impurity cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;NATOM is&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="n">natom</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">natom</span>
    
    
    <span class="k">def</span> <span class="nf">_get_magtot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract total magnetic moment ofall atoms in imp. cluster</span>
<span class="sd">        :param file: file that is parsed to find magnetic moments</span>
<span class="sd">        :returns: list of total magnetic moments of all atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO implement</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    
    <span class="k">def</span> <span class="nf">_extract_timings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract timings for the different parts in the KKRimp code</span>
<span class="sd">        :param outfile: timing file of the KKRimp run</span>
<span class="sd">        :returns: res (dict) timings in seconds, averaged over iterations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">search_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time until scf starts&#39;</span><span class="p">,</span> 
                       <span class="s1">&#39;vpot-&gt;tmat&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;gref-&gt;gmat&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;gonsite-&gt;density&#39;</span><span class="p">,</span> 
                       <span class="s1">&#39;energyloop&#39;</span><span class="p">,</span> 
                       <span class="s1">&#39;Iteration number&#39;</span><span class="p">,</span> 
                       <span class="s1">&#39;Total running time&#39;</span><span class="p">]</span>
                       
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">isearch</span> <span class="ow">in</span> <span class="n">search_keys</span><span class="p">:</span>
            <span class="n">tmpval</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">itmp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">itmp</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="n">isearch</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">itmp</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmpval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpval</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">isearch</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpval</span>
        <span class="c1"># average over iterations</span>
        <span class="n">niter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">search_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[]))</span>
        <span class="k">if</span> <span class="n">niter</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">search_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">]:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">/</span><span class="n">niter</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="n">search_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>
        
        
    <span class="k">def</span> <span class="nf">_get_nspin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract nspin from file</span>
<span class="sd">        :param file: file that is parsed</span>
<span class="sd">        :returns: 1 if calculation is paramagnetic, 2 otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;NSPIN&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nspin</span>
    
    
    <span class="k">def</span> <span class="nf">_get_spinmom_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">natom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract spin moment for all atoms</span>
<span class="sd">        :param file: file that is parsed</span>
<span class="sd">        :param natom: number of atoms in impurity cluster</span>
<span class="sd">        :returns: spinmom_at (list), spin moments for all atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO implement</span>
        <span class="k">return</span> <span class="n">spinmom_at</span>
    
    
    <span class="k">def</span> <span class="nf">_get_orbmom_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">natom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract orbital moment for all atoms</span>
<span class="sd">        :param file: file that is parsed</span>
<span class="sd">        :param natom: number of atoms in impurity cluster</span>
<span class="sd">        :returns: orbmom_at (list), orbital moments for all atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO implement</span>
        <span class="k">return</span> <span class="n">orbmom_at</span>
        
        
    <span class="k">def</span> <span class="nf">_get_EF_potfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">potfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract EF value from potential file</span>
<span class="sd">        :param potfile: file that is parsed</span>
<span class="sd">        :returns: EF (float), value of the Fermi energy in Ry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">potfile</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">EF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tmptxt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">EF</span>
        
        
    <span class="k">def</span> <span class="nf">_get_Etot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract total energy file</span>
<span class="sd">        :param file: file that is parsed</span>
<span class="sd">        :returns: Etot (list), values of the total energy in Ry for all iterations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">search_string</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">tmptxt</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">itmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Etot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">itmp</span> <span class="o">=</span> <span class="n">search_string</span><span class="p">(</span><span class="s1">&#39;TOTAL ENERGY&#39;</span><span class="p">,</span> <span class="n">tmptxt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">itmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Etot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tmptxt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">itmp</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">Etot</span>
        
        
    <span class="k">def</span> <span class="nf">_get_energies_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file1</span><span class="p">,</span> <span class="n">file2</span><span class="p">,</span> <span class="n">natom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract single particle and total energies in Ry for all atoms from file 1 and file 2</span>
<span class="sd">        :param file1: file containing all single particle energies</span>
<span class="sd">        :param file2: file containing all total energies</span>
<span class="sd">        :returns: esp_at (list), etot_at (list)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">loadtxt</span>
        <span class="n">esp</span> <span class="o">=</span> <span class="n">loadtxt</span><span class="p">(</span><span class="n">file1</span><span class="p">)</span>
        <span class="n">etot</span> <span class="o">=</span> <span class="n">loadtxt</span><span class="p">(</span><span class="n">file2</span><span class="p">)</span>
        <span class="n">esp_at</span> <span class="o">=</span> <span class="n">esp</span><span class="p">[</span><span class="o">-</span><span class="n">natom</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">etot_at</span> <span class="o">=</span> <span class="n">etot</span><span class="p">[</span><span class="o">-</span><span class="n">natom</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">esp_at</span><span class="p">,</span> <span class="n">etot_at</span>

    
    <span class="c1">### end helper functions ###</span>

    
<div class="viewcode-block" id="kkrimp_parser_functions.parse_kkrimp_outputfile"><a class="viewcode-back" href="../../../../module_guide/code.html#masci_tools.io.parsers.kkrimp_parser_functions.kkrimp_parser_functions.parse_kkrimp_outputfile">[docs]</a>    <span class="k">def</span> <span class="nf">parse_kkrimp_outputfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">,</span> <span class="n">file_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main parser function for kkrimp, read information from files in file_dict and fills out_dict</span>
<span class="sd">        :param out_dict: dictionary that is filled with parsed output of the KKRimp calculation</span>
<span class="sd">        :param file_dict: dictionary of files that are parsed</span>
<span class="sd">        :returns: success (bool), msg_list(list of error/warning messages of parser), out_dict (filled dict of parsed output)</span>
<span class="sd">        :note: file_dict should contain the following keys</span>
<span class="sd">            * &#39;outfile&#39;, the std_out of the KKRimp calculation</span>
<span class="sd">            * &#39;out_log&#39;, the out_log.000.txt file</span>
<span class="sd">            * &#39;out_pot&#39;, the output potential</span>
<span class="sd">            * &#39;out_enersp_at&#39;, the out_energysp_per_atom_eV file</span>
<span class="sd">            * &#39;out_enertot_at&#39;, the out_energytotal_per_atom_eV file</span>
<span class="sd">            * &#39;out_timing&#39;, the timing file</span>
<span class="sd">            * &#39;kkrflex_llyfac&#39;, the file for the Lloyd factor</span>
<span class="sd">            * &#39;kkrflex_angles&#39;, the nonco_angles file for the KKRimp calculation</span>
<span class="sd">            * &#39;out_spinmoms&#39;, the output spin moments file</span>
<span class="sd">            * &#39;out_orbmoms&#39;, the output orbital moments file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.parsers.kkrparser_functions</span> <span class="k">import</span> <span class="n">get_rms</span><span class="p">,</span> <span class="n">find_warnings</span><span class="p">,</span> <span class="n">get_charges_per_atom</span><span class="p">,</span> <span class="n">get_core_states</span>
        <span class="kn">from</span> <span class="nn">masci_tools.io.common_functions</span> <span class="k">import</span> <span class="n">get_version_info</span><span class="p">,</span> <span class="n">get_Ry2eV</span>
        
        <span class="n">Ry2eV</span> <span class="o">=</span> <span class="n">get_Ry2eV</span><span class="p">()</span>
        <span class="n">msg_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">file_dict</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">code_version</span><span class="p">,</span> <span class="n">compile_options</span><span class="p">,</span> <span class="n">serial_number</span> <span class="o">=</span> <span class="n">get_version_info</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;code_version&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">code_version</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;compile_options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">compile_options</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;calculation_serial_number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial_number</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;code_info_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: Version Info&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># used to group convergence info (rms, rms per atom, charge neutrality)</span>
        <span class="c1"># also initialize convegence_group where all info stored for all iterations is kept</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">result_atoms_last</span> <span class="o">=</span> <span class="n">get_rms</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;outfile&#39;</span><span class="p">],</span> <span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;rms_all_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;rms_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_atoms_last</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;rms_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;unitless&#39;</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: rms-error&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            
        <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># used to group magnetism info (spin and orbital moments)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_magtot</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;total_spin_moment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;total_spin_moment_all_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;total_spin_moment_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mu_Bohr&#39;</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;magnetism_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: total magnetic moment&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nspin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nspin</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">natom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_natom</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">newsosol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_newsosol</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;nspin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nspin</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;number_of_atoms_in_unit_cell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">natom</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;use_newsosol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newsosol</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: nspin/natom&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nspin</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1">#result, vec, angles = get_spinmom_per_atom(outfile, natom, nonco_out_file)</span>
                <span class="n">spinmom_atom</span><span class="p">,</span> <span class="n">spinmom_atom_vec_all_iter</span><span class="p">,</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_spinmom_per_atom</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_spinmom&#39;</span><span class="p">],</span> <span class="n">natom</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;spin_moment_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
                    <span class="k">if</span> <span class="n">newsosol</span><span class="p">:</span>
                        <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;spin_moment_vector_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[:]</span>
                        <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;spin_moment_angles_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[:]</span>
                        <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;spin_moment_angles_per_atom_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;degree&#39;</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;spin_moment_per_atom_all_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[:,:]</span>
                    <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;spin_moment_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mu_Bohr&#39;</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;magnetism_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: spin moment per atom&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># add orbital moments to magnetis group in parser output</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nspin</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">newsosol</span><span class="p">:</span>
                <span class="n">orbmom_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_orbmom_per_atom</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_orbmom&#39;</span><span class="p">],</span> <span class="n">natom</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;total_orbital_moment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span>
                    <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;orbital_moment_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;orbital_moment_per_atom_all_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[:,:]</span>
                    <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;orbital_moment_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mu_Bohr&#39;</span>
                    <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;magnetism_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: orbital moment&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_EF_potfile</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_pot&#39;</span><span class="p">])</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;fermi_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;fermi_energy_units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Ry&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: EF&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Etot</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">Ry2eV</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;energy_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;eV&#39;</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;total_energy_Ry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;total_energy_Ry_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Rydberg&#39;</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;total_energy_Ry_all_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: total energy&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">find_warnings</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;outfile&#39;</span><span class="p">])</span>
            <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;number_of_warnings&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;warnings_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;warnings_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: search for warnings&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_timings</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_timing&#39;</span><span class="p">])</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;timings_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;timings_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;seconds&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: timings&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">esp_at</span><span class="p">,</span> <span class="n">etot_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_energies_atom</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_enersp_at&#39;</span><span class="p">],</span> <span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_enertot_at&#39;</span><span class="p">],</span> <span class="n">natom</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;single_particle_energies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">esp_at</span><span class="o">*</span><span class="n">Ry2eV</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;single_particle_energies_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;eV&#39;</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;total_energies_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">etot_at</span><span class="o">*</span><span class="n">Ry2eV</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;total_energies_atom_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;eV&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: single particle energies&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result_WS</span><span class="p">,</span> <span class="n">result_tot</span><span class="p">,</span> <span class="n">result_C</span> <span class="o">=</span> <span class="n">get_charges_per_atom</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">niter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;rms_all_iterations&#39;</span><span class="p">])</span>
            <span class="n">natyp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result_tot</span><span class="p">)</span><span class="o">/</span><span class="n">niter</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;total_charge_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_WS</span><span class="p">[</span><span class="o">-</span><span class="n">natyp</span><span class="p">:]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;charge_core_states_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_C</span><span class="p">[</span><span class="o">-</span><span class="n">natyp</span><span class="p">:]</span>
            <span class="c1"># this check deals with the DOS case where output is slightly different</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_WS</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_C</span><span class="p">):</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;charge_valence_states_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_WS</span><span class="p">[</span><span class="o">-</span><span class="n">natyp</span><span class="p">:]</span><span class="o">-</span><span class="n">result_C</span><span class="p">[</span><span class="o">-</span><span class="n">natyp</span><span class="p">:]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;total_charge_per_atom_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;electron charge&#39;</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;charge_core_states_per_atom_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;electron charge&#39;</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;charge_valence_states_per_atom_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;electron charge&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: charges&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">econt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_econt_info</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;emin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">econt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;emin&#39;</span><span class="p">)</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;emin_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Rydberg&#39;</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;number_of_energy_points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">econt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Nepts&#39;</span><span class="p">)</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;epoints_contour&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">econt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;epts&#39;</span><span class="p">)</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;epoints_contour_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Rydberg&#39;</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;epoints_weights&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">econt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;energy_contour_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: energy contour&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ncore</span><span class="p">,</span> <span class="n">emax</span><span class="p">,</span> <span class="n">lmax</span><span class="p">,</span> <span class="n">descr_max</span> <span class="o">=</span> <span class="n">get_core_states</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_pot&#39;</span><span class="p">])</span>
            <span class="n">tmp_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;number_of_core_states_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncore</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;energy_highest_lying_core_state_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">emax</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;energy_highest_lying_core_state_per_atom_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Rydberg&#39;</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="s1">&#39;descr_highest_lying_core_state_per_atom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descr_max</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;core_states_group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: core_states&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            
        <span class="k">try</span><span class="p">:</span>    
            <span class="n">niter</span><span class="p">,</span> <span class="n">nitermax</span><span class="p">,</span> <span class="n">converged</span><span class="p">,</span> <span class="n">nmax_reached</span><span class="p">,</span> <span class="n">mixinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scfinfo</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;out_log&#39;</span><span class="p">])</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;number_of_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">niter</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;number_of_iterations_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nitermax</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;calculation_converged&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">converged</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;nsteps_exhausted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmax_reached</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;imix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mixinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;strmix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mixinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;qbound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mixinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;fcm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mixinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;convergence_group&#39;</span><span class="p">][</span><span class="s1">&#39;brymix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mixinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error parsing output of KKRimp: scfinfo&quot;</span>
            <span class="n">msg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>            
            
        <span class="c1">#convert arrays to lists</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ndarray</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">out_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">==</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">==</span><span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">])</span><span class="o">==</span><span class="n">ndarray</span><span class="p">:</span>
                        <span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        
                        
        <span class="c1"># return output with error messages if there are any</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">msg_list</span><span class="p">,</span> <span class="n">out_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="n">out_dict</span></div></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Masci-tools 0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2018, Jens Broeder.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
  </body>
</html>