"""
    Cochl. Sense API

    Cochl. Sense API allows to detect what is contained inside sound. Send audio data over the internet and discover what it contains  That page contains the openapi specification of Cochl. Sense API. Feel free to *download* and use the specification as you wish. For instance,  you could generate any client to interact with our backend by using  [openapi generator](https://openapi-generator.tech/). With `npx` and `java`  installed locally, python client could be generated by running    ``` npx @openapitools/openapi-generator-cli generate -i openapi.json -g python -o python-client ```   # noqa: E501

    The version of the OpenAPI document: v0.0.1
    Contact: support@cochl.ai
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from cochl_sense_api.api_client import ApiClient, Endpoint as _Endpoint
from cochl_sense_api.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from cochl_sense_api.model.audio_chunk import AudioChunk
from cochl_sense_api.model.create_session import CreateSession
from cochl_sense_api.model.generic_error import GenericError
from cochl_sense_api.model.session_refs import SessionRefs
from cochl_sense_api.model.session_status import SessionStatus
from cochl_sense_api.model.update_session import UpdateSession


class AudioSessionApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        def __create_session(
            self,
            create_session,
            **kwargs
        ):
            """Create Session  # noqa: E501

            Create a new session. An api key is required. Session parameters are  immutable and can be set at creation only   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.create_session(create_session, async_req=True)
            >>> result = thread.get()

            Args:
                create_session (CreateSession):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                SessionRefs
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['create_session'] = \
                create_session
            return self.call_with_http_info(**kwargs)

        self.create_session = _Endpoint(
            settings={
                'response_type': (SessionRefs,),
                'auth': [
                    'API_Key'
                ],
                'endpoint_path': '/audio_sessions/',
                'operation_id': 'create_session',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'create_session',
                ],
                'required': [
                    'create_session',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'create_session':
                        (CreateSession,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'create_session': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__create_session
        )

        def __delete_session(
            self,
            session_id,
            **kwargs
        ):
            """Delete Session  # noqa: E501

            Change state of session to *deleted*. All future call on the session  will return 404   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.delete_session(session_id, async_req=True)
            >>> result = thread.get()

            Args:
                session_id (str): session id represents unique identifier for an audio session 

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                None
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['session_id'] = \
                session_id
            return self.call_with_http_info(**kwargs)

        self.delete_session = _Endpoint(
            settings={
                'response_type': None,
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}',
                'operation_id': 'delete_session',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                ],
                'required': [
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                },
                'location_map': {
                    'session_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__delete_session
        )

        def __read_status(
            self,
            session_id,
            **kwargs
        ):
            """Read Status  # noqa: E501

            Get session status  *Note that if all chunks didn't finish to be inferenced, server will  wait at least one result to be  available in the required page range before returning result. Such waiting can lead to http requests timeout. Therefore we recommand to implement a client retry logic*   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.read_status(session_id, async_req=True)
            >>> result = thread.get()

            Args:
                session_id (str): session id represents unique identifier for an audio session 

            Keyword Args:
                offset (int): how many existing elements to skip before returning the first result control how many result to receive . [optional] if omitted the server will use the default value of 0
                count (int): limit the length of the returned results array to limit size of the returned payload  . [optional] if omitted the server will use the default value of 1024
                next_token (str): next token can be used from a previous page result. It allows to  iterate through all next elements of a collection. If next_token is  set, offset and limit will be ignored . [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                SessionStatus
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['session_id'] = \
                session_id
            return self.call_with_http_info(**kwargs)

        self.read_status = _Endpoint(
            settings={
                'response_type': (SessionStatus,),
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}/status',
                'operation_id': 'read_status',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'offset',
                    'count',
                    'next_token',
                ],
                'required': [
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'offset',
                    'count',
                ]
            },
            root_map={
                'validations': {
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                    ('count',): {

                        'inclusive_maximum': 1024,
                        'inclusive_minimum': 0,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'offset':
                        (int,),
                    'count':
                        (int,),
                    'next_token':
                        (str,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                    'offset': 'offset',
                    'count': 'count',
                    'next_token': 'next_token',
                },
                'location_map': {
                    'session_id': 'path',
                    'offset': 'query',
                    'count': 'query',
                    'next_token': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__read_status
        )

        def __update_session(
            self,
            session_id,
            update_session,
            **kwargs
        ):
            """Update Session  # noqa: E501

            Update a session   # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.update_session(session_id, update_session, async_req=True)
            >>> result = thread.get()

            Args:
                session_id (str): session id represents unique identifier for an audio session 
                update_session (UpdateSession):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                None
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['session_id'] = \
                session_id
            kwargs['update_session'] = \
                update_session
            return self.call_with_http_info(**kwargs)

        self.update_session = _Endpoint(
            settings={
                'response_type': None,
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}',
                'operation_id': 'update_session',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'update_session',
                ],
                'required': [
                    'session_id',
                    'update_session',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'update_session':
                        (UpdateSession,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                },
                'location_map': {
                    'session_id': 'path',
                    'update_session': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__update_session
        )

        def __upload_chunk(
            self,
            session_id,
            chunk_sequence,
            audio_chunk,
            **kwargs
        ):
            """Upload Chunk  # noqa: E501

            Upload new audio chunk    # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True

            >>> thread = api.upload_chunk(session_id, chunk_sequence, audio_chunk, async_req=True)
            >>> result = thread.get()

            Args:
                session_id (str): session id represents unique identifier for an audio session 
                chunk_sequence (int): chunk represent the chunk number. This is needs to be  counter  starting from 0 and growing by one on each requests  
                audio_chunk (AudioChunk): raw binary chunk 

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int/None): specifies the index of the server
                    that we want to use.
                    Default is read from the configuration.
                async_req (bool): execute request asynchronously

            Returns:
                SessionRefs
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index')
            kwargs['session_id'] = \
                session_id
            kwargs['chunk_sequence'] = \
                chunk_sequence
            kwargs['audio_chunk'] = \
                audio_chunk
            return self.call_with_http_info(**kwargs)

        self.upload_chunk = _Endpoint(
            settings={
                'response_type': (SessionRefs,),
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}/chunks/{chunk_sequence}',
                'operation_id': 'upload_chunk',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'chunk_sequence',
                    'audio_chunk',
                ],
                'required': [
                    'session_id',
                    'chunk_sequence',
                    'audio_chunk',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'chunk_sequence':
                        (int,),
                    'audio_chunk':
                        (AudioChunk,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                    'chunk_sequence': 'chunk_sequence',
                },
                'location_map': {
                    'session_id': 'path',
                    'chunk_sequence': 'path',
                    'audio_chunk': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__upload_chunk
        )
